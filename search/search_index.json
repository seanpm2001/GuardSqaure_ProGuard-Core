{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"ProGuardCORE is a free library to read, analyze, modify, and write Java class files. It is the core of the well-known shrinker, optimizer, and obfuscator ProGuard and of the ProGuard Assembler and Disassembler . Typical applications: Perform peephole optimizations in Java bytecode. Search for instruction patterns. Analyze code with abstract evaluation. Optimize and obfuscate, like ProGuard itself. Design The library defines many small classes as the building blocks for applications that contain the processing logic. This is sometimes taken to the extreme: even loops and conditional statements can often be implemented as separate classes. Even though these classes are verbose and repetitive, the resulting main code becomes much more compact, flexible, and robust. Data classes Basic data classes define the structures to represent Java bytecode. They reflect the Java bytecode specifications literally, to ensure that no data are lost when reading, analyzing, and writing them. The data classes contain only a minimum number of methods. They do have one or more accept methods to let the visitor classes below operate on them. Visitor classes The library applies the visitor pattern extensively. Visitor classes define the operations on the data: reading, writing, editing, transforming, analyzing, etc. The visitor classes have one or more 'visit' methods to operate on data classes of the same basic type. For example, a Java bytecode class contains a constant pool with constants of different types: integer constants, float constants, string constants, etc. The data classes IntegerConstant, FloatConstant, StringConstant, etc. all implement the basic type Constant. The visitor interface ConstantVisitor contains methods 'visitIntegerConstant', 'visitFloatConstant', 'visitStringConstant', etc. Implementations of this visitor interface can perform all kinds of operations on the constants. The reasoning behind this pattern is that the data classes are very stable, because they are directly based on the bytecode specifications. The operations are more dynamic, since they depend on the final application. It is practically impossible to add all possible operations in the data classes, but it is easy to add another implementation of a visitor interface. Implementing an interface in practice helps a lot to think of all possible cases. The visitor pattern uses visitor interfaces to operate on the similar elements of a data structure. Each interface often has many implementations. A great disadvantage at this time is that visitor methods can invoke one another (directly or indirectly), but they can't communicate easily. Since the implementations can't add their own parameters or return values, they often have to rely on fields to pass values back and forth. This is more error-prone. Still, the advantages of the visitor pattern outweigh the disadvantages. Dependency injection The library classes heavily use constructor-based dependency injection , to create immutable instances. Notably the visitor classes are often like commands that are combined in an immutable structure, via constructors. You can execute such commands by applying the visitors to the data classes. API You can find the complete API in the ProGuardCORE javadoc .","title":"Introduction"},{"location":"index.html#design","text":"The library defines many small classes as the building blocks for applications that contain the processing logic. This is sometimes taken to the extreme: even loops and conditional statements can often be implemented as separate classes. Even though these classes are verbose and repetitive, the resulting main code becomes much more compact, flexible, and robust.","title":"Design"},{"location":"index.html#data-classes","text":"Basic data classes define the structures to represent Java bytecode. They reflect the Java bytecode specifications literally, to ensure that no data are lost when reading, analyzing, and writing them. The data classes contain only a minimum number of methods. They do have one or more accept methods to let the visitor classes below operate on them.","title":"Data classes"},{"location":"index.html#visitor-classes","text":"The library applies the visitor pattern extensively. Visitor classes define the operations on the data: reading, writing, editing, transforming, analyzing, etc. The visitor classes have one or more 'visit' methods to operate on data classes of the same basic type. For example, a Java bytecode class contains a constant pool with constants of different types: integer constants, float constants, string constants, etc. The data classes IntegerConstant, FloatConstant, StringConstant, etc. all implement the basic type Constant. The visitor interface ConstantVisitor contains methods 'visitIntegerConstant', 'visitFloatConstant', 'visitStringConstant', etc. Implementations of this visitor interface can perform all kinds of operations on the constants. The reasoning behind this pattern is that the data classes are very stable, because they are directly based on the bytecode specifications. The operations are more dynamic, since they depend on the final application. It is practically impossible to add all possible operations in the data classes, but it is easy to add another implementation of a visitor interface. Implementing an interface in practice helps a lot to think of all possible cases. The visitor pattern uses visitor interfaces to operate on the similar elements of a data structure. Each interface often has many implementations. A great disadvantage at this time is that visitor methods can invoke one another (directly or indirectly), but they can't communicate easily. Since the implementations can't add their own parameters or return values, they often have to rely on fields to pass values back and forth. This is more error-prone. Still, the advantages of the visitor pattern outweigh the disadvantages.","title":"Visitor classes"},{"location":"index.html#dependency-injection","text":"The library classes heavily use constructor-based dependency injection , to create immutable instances. Notably the visitor classes are often like commands that are combined in an immutable structure, via constructors. You can execute such commands by applying the visitors to the data classes.","title":"Dependency injection"},{"location":"index.html#api","text":"You can find the complete API in the ProGuardCORE javadoc .","title":"API"},{"location":"building.html","text":"If you've downloaded the source code of the ProGuardCORE library, you can build it yourself with Gradle: Build the artifacts: ./gradlew assemble Publish the artifacts to your local Maven cache (something like ~/.m2/ ): ./gradlew publishToMavenLocal Build tar and zip archives with the binaries and documentation: ./gradlew distTar distZip Build the complete API documentation with ./gradlew javadoc You can then find the API documentation in docs/md/api .","title":"Building"},{"location":"creating.html","text":"The easiest way to create a new class from scratch is with ClassBuilder. It provides a fluent API to add fields and methods. For example, to create a class that prints out \"Hello, world!\": ProgramClass programClass = new ClassBuilder ( VersionConstants . CLASS_VERSION_1_8 , AccessConstants . PUBLIC , \"HelloWorld\" , ClassConstants . NAME_JAVA_LANG_OBJECT ) . addMethod ( AccessConstants . PUBLIC | AccessConstants . STATIC , \"main\" , \"([Ljava/lang/String;)V\" , 50 , code -> code . getstatic ( \"java/lang/System\" , \"out\" , \"Ljava/io/PrintStream;\" ) . ldc ( \"Hello, world!\" ) . invokevirtual ( \"java/io/PrintStream\" , \"println\" , \"(Ljava/lang/String;)V\" ) . return_ ()) . getProgramClass (); You can also use it to add fields and methods to an existing class: ProgramClass programClass = new ClassBuilder ( existingClass ) ..... Complete example: CreateHelloWorldClass.java","title":"Creating classes"},{"location":"downloads.html","text":"The ProGuardCORE library is distributed under the terms of the Apache License Version 2.0. Please consult the license page for more details. ProGuardCORE is written in Java, so it requires a Java Runtime Environment (JRE 1.8 or higher). You can download the library in various forms: Pre-built artifacts at Maven Central dependencies { compile project ( ':com.guardsquare:proguard-core:9.0.0' ) } or <dependency> <groupId> com.guardsquare </groupId> <artifactId> proguard-core </artifactId> <version> 9.0.0 </version> </dependency> A Git repository of the source code at Github git clone https://github.com/Guardsquare/proguard-core.git You can find major releases, minor releases with important bug fixes, and beta releases with the latest new features and any less urgent bug fixes. If you're still working with an older version of the library, check out the release notes , to see if you're missing something essential.","title":"Downloads"},{"location":"editing.html","text":"Editing classes You can edit existing classes with ClassEditor and related editors like InterfacesEditor, AttributesEditor, and ConstantPoolEditor. ClassEditor classEditor = new ClassEditor ( targetClass ); classEditor . addField ( field ); classEditor . addMethod ( method ); If you want to create and add new fields or methods from scratch, you can use the more convenient ClassBuilder: ProgramClass programClass = new ClassBuilder ( existingClass ) . addField ( AccessConstants . PUBLIC | AccessConstants . STATIC , \"someField\" , TypeConstants . INT ); . addMethod ( AccessConstants . PUBLIC | AccessConstants . STATIC , \"main\" , \"([Ljava/lang/String;)V\" , 50 , code -> code . getstatic ( \"java/lang/System\" , \"out\" , \"Ljava/io/PrintStream;\" ) . ldc ( \"Hello, world!\" ) . invokevirtual ( \"java/io/PrintStream\" , \"println\" , \"(Ljava/lang/String;)V\" ) . return_ ()) . getProgramClass (); Editing code Perhaps more interestingly, you can edit the bytecode of method bodies with CodeAttributeEditor. CodeAttributeEditor codeAttributeEditor = new CodeAttributeEditor (); InstructionSequenceBuilder builder = new InstructionSequenceBuilder ( targetClass ); Instructions [] replacementInstructions = builder . getstatic ( \"java/lang/System\" , \"out\" , \"Ljava/io/ .ldc(\" Hello \") .invokevirtual(\" java / io / PrintStream \", \" println \", \" ( Ljava / lang / String ;) V \" . instructions (); // Prepare the editor for this code. codeAttributeEditor . reset ( codeAttribute . u4codeLength ); // Insert the instruction sequence before a specified offset. codeAttributeEditor . insertBeforeOffset ( offset , replacementInstructions ); // Apply the changes. codeAttributeEditor . visitCodeAttribute ( clazz , method , codeAttribute );","title":"Editing classes"},{"location":"editing.html#editing-classes","text":"You can edit existing classes with ClassEditor and related editors like InterfacesEditor, AttributesEditor, and ConstantPoolEditor. ClassEditor classEditor = new ClassEditor ( targetClass ); classEditor . addField ( field ); classEditor . addMethod ( method ); If you want to create and add new fields or methods from scratch, you can use the more convenient ClassBuilder: ProgramClass programClass = new ClassBuilder ( existingClass ) . addField ( AccessConstants . PUBLIC | AccessConstants . STATIC , \"someField\" , TypeConstants . INT ); . addMethod ( AccessConstants . PUBLIC | AccessConstants . STATIC , \"main\" , \"([Ljava/lang/String;)V\" , 50 , code -> code . getstatic ( \"java/lang/System\" , \"out\" , \"Ljava/io/PrintStream;\" ) . ldc ( \"Hello, world!\" ) . invokevirtual ( \"java/io/PrintStream\" , \"println\" , \"(Ljava/lang/String;)V\" ) . return_ ()) . getProgramClass ();","title":"Editing classes"},{"location":"editing.html#editing-code","text":"Perhaps more interestingly, you can edit the bytecode of method bodies with CodeAttributeEditor. CodeAttributeEditor codeAttributeEditor = new CodeAttributeEditor (); InstructionSequenceBuilder builder = new InstructionSequenceBuilder ( targetClass ); Instructions [] replacementInstructions = builder . getstatic ( \"java/lang/System\" , \"out\" , \"Ljava/io/ .ldc(\" Hello \") .invokevirtual(\" java / io / PrintStream \", \" println \", \" ( Ljava / lang / String ;) V \" . instructions (); // Prepare the editor for this code. codeAttributeEditor . reset ( codeAttribute . u4codeLength ); // Insert the instruction sequence before a specified offset. codeAttributeEditor . insertBeforeOffset ( offset , replacementInstructions ); // Apply the changes. codeAttributeEditor . visitCodeAttribute ( clazz , method , codeAttribute );","title":"Editing code"},{"location":"kotlin.html","text":"Kotlin metadata The library makes it easy to read, write and modify the Kotlin metadata that is attached to Java classes. The following example prints all the names of Kotlin functions in the metadata attached to the Java class Foo : programClassPool . classesAccept ( new ClassNameFilter ( \"Foo\" , new ReferencedKotlinMetadataVisitor ( new AllFunctionsVisitor ( ( clazz , container , function ) -> System . out . println ( function . name ))))); Initializing the Kotlin metadata model There are two ways to initialize the Kotlin metadata model: While reading classes with ClassReader by setting includeKotlinMetadata to true . After class reading using KotlinMetadataInitializer . KotlinMetadataInitializer The KotlinMetadataInitializer can be used as a ClassVisitor which will read the Kotlin metadata from the kotlin.Metadata annotation on program classes ( ProgramClass ) and automatically initialize the metadata model on visited classes: BiConsumer < Clazz , String > errorHandler = ( clazz , message ) -> System . err . println ( message ); programClassPool . classesAccept ( new KotlinMetadataInitializer ( errorHandler )); Alternatively, the initialize(Clazz, int, int[], String[], String[], int, String, String) can be called directly with a Clazz and the components making up the kotlin.Metadata annotation: BiConsumer < Clazz , String > errorHandler = ( clazz , message ) -> System . err . println ( message ); KotlinMetadataInitializer initializer = new KotlinMetadataInitializer ( errorHandler ); programClassPool . classesAccept ( clazz -> { // get the values for k, mv, d1, d2, xi, xs, pn to provide to the initializer initializer . initialize ( clazz , k , mv , d1 , d2 , xi , xs , pn ); } ); This is useful for initializing the model on library classes ( LibraryClass ), since the library class model doesn't contain all the necessary information to automatically extract these parameters. Initializing references Once the model itself is initialized by KotlinMetadataInitializer , like the Clazz model, references must be initialized. This is done by the ClassReferenceInitializer : // First build the model BiConsumer < Clazz , String > errorHandler = ( clazz , message ) -> System . err . println ( message ); programClassPool . classesAccept ( new KotlinMetadataInitializer ( errorHandler )); // Then initialize the references programClassPool . classesAccept ( new ClassReferenceInitializer ( programClassPool , libraryClassPool ) );","title":"Kotlin metadata"},{"location":"kotlin.html#kotlin-metadata","text":"The library makes it easy to read, write and modify the Kotlin metadata that is attached to Java classes. The following example prints all the names of Kotlin functions in the metadata attached to the Java class Foo : programClassPool . classesAccept ( new ClassNameFilter ( \"Foo\" , new ReferencedKotlinMetadataVisitor ( new AllFunctionsVisitor ( ( clazz , container , function ) -> System . out . println ( function . name )))));","title":"Kotlin metadata"},{"location":"kotlin.html#initializing-the-kotlin-metadata-model","text":"There are two ways to initialize the Kotlin metadata model: While reading classes with ClassReader by setting includeKotlinMetadata to true . After class reading using KotlinMetadataInitializer .","title":"Initializing the Kotlin metadata model"},{"location":"kotlin.html#kotlinmetadatainitializer","text":"The KotlinMetadataInitializer can be used as a ClassVisitor which will read the Kotlin metadata from the kotlin.Metadata annotation on program classes ( ProgramClass ) and automatically initialize the metadata model on visited classes: BiConsumer < Clazz , String > errorHandler = ( clazz , message ) -> System . err . println ( message ); programClassPool . classesAccept ( new KotlinMetadataInitializer ( errorHandler )); Alternatively, the initialize(Clazz, int, int[], String[], String[], int, String, String) can be called directly with a Clazz and the components making up the kotlin.Metadata annotation: BiConsumer < Clazz , String > errorHandler = ( clazz , message ) -> System . err . println ( message ); KotlinMetadataInitializer initializer = new KotlinMetadataInitializer ( errorHandler ); programClassPool . classesAccept ( clazz -> { // get the values for k, mv, d1, d2, xi, xs, pn to provide to the initializer initializer . initialize ( clazz , k , mv , d1 , d2 , xi , xs , pn ); } ); This is useful for initializing the model on library classes ( LibraryClass ), since the library class model doesn't contain all the necessary information to automatically extract these parameters.","title":"KotlinMetadataInitializer"},{"location":"kotlin.html#initializing-references","text":"Once the model itself is initialized by KotlinMetadataInitializer , like the Clazz model, references must be initialized. This is done by the ClassReferenceInitializer : // First build the model BiConsumer < Clazz , String > errorHandler = ( clazz , message ) -> System . err . println ( message ); programClassPool . classesAccept ( new KotlinMetadataInitializer ( errorHandler )); // Then initialize the references programClassPool . classesAccept ( new ClassReferenceInitializer ( programClassPool , libraryClassPool ) );","title":"Initializing references"},{"location":"license.html","text":"The ProGuardCORE library is licensed under the Apache License Version 2.0. Copyright 2002-2020 Guardsquare NV Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS","title":"License"},{"location":"partialevaluator.html","text":"Analyzing all instructions If you want to analyze bytecode, you'll probably want to visit specified instructions of specified code attributes of specified methods of specified classes. The visitor classes and filters quickly get you to the right place: programClassPool . classesAccept ( new AllMethodVisitor ( new AllAttributeVisitor ( new AllInstructionVisitor ( new MyInstructionAnalyzer ())))); You then only need to implement the visitor methods to analyze the instructions: class MyInstructionAnalyzer implements InstructionVisitor { public void visitSimpleInstruction ( Clazz clazz , .....) ... public void visitVariableInstruction ( Clazz clazz , .....) ... public void visitConstantInstruction ( Clazz clazz , .....) ... public void visitBranchInstruction ( Clazz clazz , .....) ... public void visitTableSwitchInstruction ( Clazz clazz , .....) ... public void visitLookUpSwitchInstruction ( Clazz clazz , .....) ... } The library already provides classes to analyze the code for you, finding branching information, performing partial evaluation, finding the control flow and data flow, etc, as introduced in the following sections. Complete example: EvaluateReturnValues.java Collecting basic branching information You can extract basic information about branches in a method with the class BranchTargetFinder. The results are defined at the instruction level: each instruction is properly labeled as a branch target, branch origin, exception handler, etc. BranchTargetFinder branchTargetFinder = new BranchTargetFinder (); branchTargetFinder . visitCodeAttribute ( clazz , method , codeAttribute ); if ( branchTargetFinder . isBranchOrigin ( offset )) ... if ( branchTargetFinder . isBranchTarget ( offset )) ... Complete example: ApplyPeepholeOptimizations.java Partial evaluation You can extract more information about the code with partial evaluation (often called abstract evaluation or symbolic evaluation). Its analysis provides a global view of the control flow and data flow in a method. The core class is PartialEvaluator. It can work at different levels of precision \u2014 the more abstract, the less precise. You can control the precision with different value factories and different invocation units: A ValueFactory defines the level of detail in representing values like integers or reference types. The values can be very abstract (any primitive integer, a reference to any object) or more precise (the integer 42, or an integer between 0 and 5, or a non-null reference to an instance of java/lang/String). An InvocationUnit defines the values returned from retrieved fields and invoked methods. The values can again be very generic (any integer) or they can also be values that were cached in prior evaluations of the code base. Complete example: EvaluateCode.java, which provides options to analyze code with different levels of precision. It prints out its results in markdown format, which is also used in the examples below. Control flow analysis You can set up basic evaluation with a BasicValueFactory and a BasicInvocationUnit: ValueFactory valueFactory = new BasicValueFactory (); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The analysis provides a control flow graph of the instructions in a method. Each instruction is labeled with potential branch targets and branch origins: InstructionOffsetValue branchOrigins = partialEvaluator . branchOrigins ( offset )); InstructionOffsetValue branchTargets = partialEvaluator . branchTargets ( offset )); Complete example: VisualizeControlFlow.java Data flow analysis You can also inspect the data flow between the instructions in a method by looking at the stack and the local variables: TracedStack stack = partialEvaluator . getStackAfter ( offset ); TracedVariables variables = partialEvaluator . getVariablesAfter ( offset ); Consider the following code: public static int getAnswer () { int f1 = 6 ; int f2 = 7 ; return f1 * f2 ; } Applying the above partial evaluator to this code yields this overall result: Instruction Stack v0 v1 [0] bipush 6 [0:i] empty empty [2] istore_0 v0 2:i empty [3] bipush 7 [3:i] 2:i empty [5] istore_1 v1 2:i 5:i [6] iload_0 v0 [6:i] 2:i 5:i [7] iload_1 v1 [6:i] [7:i] 2:i 5:i [8] imul [8:i] 2:i 5:i [9] ireturn 2:i 5:i Each integer value followed by a colon indicates the offset of the instruction that stored or pushed the value. Each 'i' indicates an unknown primitive integer value. Useful applications: dependency analysis at an instruction level, for example to remove unused instructions. Complete example: EvaluateCode.java More precise numerical evaluation The above basic evaluation doesn't tell you much about any numerical results. You can set up more precise numerical evaluation with a ParticularValueFactory: ValueFactory valueFactory = new ParticularValueFactory ( new BasicValueFactory ()); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); For the same code as in the previous section: Instruction Stack v0 v1 [0] bipush 6 [0:6] empty empty [2] istore_0 v0 2:6 empty [3] bipush 7 [3:7] 2:6 empty [5] istore_1 v1 2:6 5:7 [6] iload_0 v0 [6:6] 2:6 5:7 [7] iload_1 v1 [6:6] [7:7] 2:6 5:7 [8] imul [8:42] 2:6 5:7 [9] ireturn 2:6 5:7 In this trivial example, the previously unknown integers are now all concrete values. The last instruction pops the computed result 42 from the stack and returns it. Useful application: constant propagation. Evaluation with numeric ranges Consider the following code: public static int getAnswer () { int answer = 0 ; for ( int counter = 0 ; counter < 3 && Math . random () < 0.5f ; counter ++ ) { answer += 14 ; } return answer ; } The possible answer isn't a single value. You can let the evaluation work with integer ranges with a RangeValueFactory: ValueFactory valueFactory = new RangeValueFactory ( new ArrayReferenceValueFactory (), new BasicValueFactory ()); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The overall result of the analysis of the sample method is: Instruction Stack v0 v1 [0] iconst_0 [0:0] empty empty [1] istore_0 v0 1:0 empty [2] iconst_0 [2:0] 1:0 empty [3] istore_1 v1 1:0 3:0 [4] iload_1 v1 [4:0..3] 1,19:0..42 3,22:0..3 [5] iconst_3 [4:0..3] [5:3] 1,19:0..42 3,22:0..3 [6] if_icmpge +22 (target=28) 1,19:0..42 3,22:0..3 [9] invokestatic #2 [9:T] [9:d] 1,19:0..28 3,22:0..2 [12] ldc2_w #3 [9:T] [9:d] [12:T] [12:0.5d] 1,19:0..28 3,22:0..2 [15] dcmpg [15:i] 1,19:0..28 3,22:0..2 [16] ifge +12 (target=28) 1,19:0..28 3,22:0..2 [19] iinc v0, 14 19:14..42 3,22:0..2 [22] iinc v1, 1 19:14..42 22:1..3 [25] goto -21 (target=4) 19:14..42 22:1..3 [28] iload_0 v0 [28:0..42] 1,19:0..42 3,22:0..3 [29] ireturn 1,19:0..42 3,22:0..3 Not all values are entirely concrete; they can have a range (with \"..\"). The method can return a value between 0 and 42. Useful applications: simplification of range checks. Symbolic numerical evaluation Consider the following code: private static int getAnswer ( int a , int b ) { return 2 * a + b ; } The numerical evaluation of the previous sections doesn't get you very far, since the parameters are unknown, so all computations produce unknown values: Instruction Stack v0 v1 [0] iconst_2 [0:2] P0:i P1:i [1] iload_0 v0 [0:2] [1:i] P0:i P1:i [2] imul [2:i] P0:i P1:i [3] iload_1 v1 [2:i] [3:i] P0:i P1:i [4] iadd [4:i] P0:i P1:i [5] ireturn P0:i P1:i You can set up symbolic evaluation with an IdentifiedValueFactory: ValueFactory valueFactory = new IdentifiedValueFactory (); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The overall result of the analysis of the sample method is: Instruction Stack v0 v1 [0] iconst_2 [0:2] P0:i0 P1:i1 [1] iload_0 v0 [0:2] [1:i0] P0:i0 P1:i1 [2] imul [2:(2*i0)] P0:i0 P1:i1 [3] iload_1 v1 [2:(2*i0)] [3:i1] P0:i0 P1:i1 [4] iadd [4:((2*i0)+i1)] P0:i0 P1:i1 [5] ireturn P0:i0 P1:i1 The unknown values now have symbolic names (IDs): \"i0\" and \"i1\". Any computations result in symbolic expressions, such as \"((2*i0)+i1)\". Useful applications: a basis for symbolic simplification, static single assignment, further analysis with SMT solvers (satisfiability modulo theories). Evaluation with reference types The previous sections only showed examples with primitive types. Consider the following code with reference types: public static Number getAnswer ( Number answer ) { if ( answer == null ) { answer = new Integer ( 42 ); } return answer ; } The basic or numeric evaluation of the previuous sections don't tell much about the non-primitive types: Instruction Stack v0 [0] aload_0 v0 [0:a] P0:a [1] ifnonnull +13 (target=14) P0:a [4] new #2 [4:a] P0:a [7] dup [4:7:a] [4:7:a] P0:a [8] bipush 42 [4:7:a] [4:7:a] [8:42] P0:a [10] invokespecial #3 [4:7:a] P0:a [13] astore_0 v0 13:a [14] aload_0 v0 [14:a] P0,13:a [15] areturn P0,13:a Unknown reference types are shown as \"a\". You can keep track of origins of references in more detail with a ReferenceTracingValueFactory and a ReferenceTracingInvocationUnit. The PartialEvaluator is set up slightly differently from the earlier examples: ReferenceTracingValueFactory valueFactory = new ReferenceTracingValueFactory ( new BasicValueFactory ()) : InvocationUnit invocationUnit = new ReferenceTracingInvocationUnit ( new BasicInvocationUnit ( valueFactory )); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false , valueFactory ); The results then show the origins of non-primitive types: Instruction Stack v0 [0] aload_0 v0 [0:P0:a] P0:P0:a [1] ifnonnull +13 (target=14) P0:P0:a [4] new #2 [4:N4:a] P0:P0:a [7] dup [4:7:N4:a] [4:7:N4:a] P0:P0:a [8] bipush 42 [4:7:N4:a] [4:7:N4:a] [8:i] P0:P0:a [10] invokespecial #3 [4:7:N4:a] P0:P0:a [13] astore_0 v0 13:N4:a [14] aload_0 v0 [14:N4,P0:a] P0,13:N4,P0:a [15] areturn P0,13:N4,P0:a For example, the method pops and returns either a new instance (\"N4\") that was created at offset 4, or parameter 0 (\"P0\"). Useful applications: define/use analysis, a basis for escape analysis or taint analysis. Evaluation with more precise reference types You can keep track of non-primitive types in more detail with a TypedReferenceValueFactory: ValueFactory valueFactory = new TypedReferenceValueFactory (); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The results then show the types: Instruction Stack v0 [0] aload_0 v0 [0:Ljava/lang/Number;] P0:Ljava/lang/Number; [1] ifnonnull +13 (target=14) P0:Ljava/lang/Number; [4] new #2 [4:Ljava/lang/Integer;=!] P0:Ljava/lang/Number; [7] dup [4:7:Ljava/lang/Integer;=!] [4:7:Ljava/lang/Integer;=!] P0:Ljava/lang/Number; [8] bipush 42 [4:7:Ljava/lang/Integer;=!] [4:7:Ljava/lang/Integer;=!] [8:i] P0:Ljava/lang/Number; [10] invokespecial #3 [4:7:Ljava/lang/Integer;=!] P0:Ljava/lang/Number; [13] astore_0 v0 13:Ljava/lang/Integer;=! [14] aload_0 v0 [14:Ljava/lang/Number;] P0,13:Ljava/lang/Number; [15] areturn P0,13:Ljava/lang/Number; The types here are \"Ljava/lang/Number;\" and \"Ljava/lang/Integer;\". The types respect the type hierarchy, for example when the branches join and the type is \"Ljava/lang/Number;\". A mark \"=\" means that the type is the exact type, not an extension. A mark \"!\" means that the value is definitely not null. Useful applications: preverification of the type safety of bytecode. Note on type variables naming convention PGC has different representation for type string variables: External class name: com.guardsquare.SomeClass Internal class name: com/guardsquare/SomeClass Internal type (or just type ): Lcom/guardsquare/SomeClass; (for arrays e.g. [I , [Ljava/lang/Object; ) Internal class type: com/guardsquare/SomeClass (for arrays this is their internal type e.g. [I , [Ljava/lang/Object; ) See proguard.classfile.util.ClassUtil for useful methods to convert between the different representations. Evaluation with primitive arrays Primitive arrays may be of special interest, for example when performing optimizations. Consider the following code: public static int getAnswer () { int [] array = new int [] { 6 , 7 }; return array [ 0 ] * array [ 1 ] ; } Even though this is a trivial example, the previous evaluations wouldn't provide much useful information: Instruction Stack v0 [0] iconst_2 [0:i] empty [1] newarray 10 [1:[I?=![i]] empty [3] dup [1:3:[I?=![i]] [1:3:[I?=![i]] empty [4] iconst_0 [1:3:[I?=![i]] [1:3:[I?=![i]] [4:i] empty [5] bipush 6 [1:3:[I?=![i]] [1:3:[I?=![i]] [4:i] [5:i] empty [7] iastore [1:3:[I?=![i]] empty [8] dup [1:8:[I?=![i]] [1:8:[I?=![i]] empty [9] iconst_1 [1:8:[I?=![i]] [1:8:[I?=![i]] [9:i] empty [10] bipush 7 [1:8:[I?=![i]] [1:8:[I?=![i]] [9:i] [10:i] empty [12] iastore [1:8:[I?=![i]] empty [13] astore_0 v0 13:[I?=![i] [14] aload_0 v0 [14:[I?=![i]] 13:[I?=![i] [15] iconst_0 [14:[I?=![i]] [15:i] 13:[I?=![i] [16] iaload [16:i] 13:[I?=![i] [17] aload_0 v0 [16:i] [17:[I?=![i]] 13:[I?=![i] [18] iconst_1 [16:i] [17:[I?=![i]] [18:i] 13:[I?=![i] [19] iaload [16:i] [19:i] 13:[I?=![i] [20] imul [20:i] 13:[I?=![i] [21] ireturn 13:[I?=![i] The array type is \"[I\", which is the standard notation for an array of primitive integers. You can keep track of the lengths of arrays with ArrayReferenceValueFactory and even of the contents of primitive arrays with DetailedArrayValueFactory: ValueFactory valueFactory = new DetailedArrayValueFactory (); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The results of the evaluation then become: Instruction Stack v0 [0] iconst_2 [0:2] empty [1] newarray 10 [1:[I?=![2]#0 empty [3] dup [1:3:[I?=![2]#0 empty [4] iconst_0 [1:3:[I?=![2]#0 empty [5] bipush 6 [1:3:[I?=![2]#0 empty [7] iastore [1:3:[I?=![2]#0 empty [8] dup [1:8:[I?=![2]#0 empty [9] iconst_1 [1:8:[I?=![2]#0 empty [10] bipush 7 [1:8:[I?=![2]#0 empty [12] iastore [1:8:[I?=![2]#0 empty [13] astore_0 v0 13:[I?=![2]#0 [14] aload_0 v0 [14:[I?=![2]#0 13:[I?=![2]#0 [15] iconst_0 [14:[I?=![2]#0 13:[I?=![2]#0 [16] iaload [16:6] 13:[I?=![2]#0 [17] aload_0 v0 [16:6] [17:[I?=![2]#0 13:[I?=![2]#0 [18] iconst_1 [16:6] [17:[I?=![2]#0 13:[I?=![2]#0 [19] iaload [16:6] [19:7] 13:[I?=![2]#0 [20] imul [20:42] 13:[I?=![2]#0 [21] ireturn 13:[I?=![2]#0 The array is now traced as having length 2 and elements 6 and 7. Useful application: simplification of code with enum types. Evaluation with particular reference values The values of references can also be of interest. Consider the following code: public StringBuilder append () { StringBuilder s = new StringBuilder ( \"asd\" ); s . append ( \"fgh\" ); return s ; } If the value of s is of interest, this can be retrieved using a ParticularValueFactory . To also keep track of the references as they flow through method calls (in the example: the constructor-call, and the append ), the InvocationUnit needs to be a ExecutingInvocationUnit : ValueFactory valueFactory = new ParticularValueFactory ( new BasicValueFactory (), new ParticularValueFactory . ReferenceValueFactory ()); ExecutingInvocationUnit invocationUnit = new ExecutingInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The results of the evaluation then become: Instruction Stack (before the Instruction) v0 (before the Instruction) [0] new StringBuilder [empty:empty] [3] dup [0:StringBuilder=!#0] [empty:empty] [4] ldc \"asd\" [3:0:StringBuilder=!#0] [3:0:StringBuilder=!#0] [empty:empty] [6] invokespecial StringBuilder.<init>(String)V [4:String?=#1(asd)] [3:0:StringBuilder=!#0] [3:0:StringBuilder=!#0] [empty:empty] [9] astore_0 v0 [3:0:StringBuilder=#2(asd)] [empty:empty] [10] aload_0 v0 [9:StringBuilder=#2(asd)] [11] ldc \"fgh\" [10:StringBuilder=#2(asd)] [9:StringBuilder=#2(asd)] [13] invokevirtual StringBuilder.append(String)StringBuilder [11:String?=#3(fgh)] [10:StringBuilder=#2(asd)] [9:StringBuilder=#2(asd)] [16] pop [13:StringBuilder=#4(asdfgh)] [13:StringBuilder=#4(asdfgh)] [17] aload_0 v0 [13:StringBuilder=#4(asdfgh)] [18] areturn [17:StringBuilder=#4(asdfgh)] [13:StringBuilder=#4(asdfgh)] (Class/String constants are added to the instruction, and java/lang/ is ommited from the class names for clarity) The StringBuilder is now traced through the method, the value of the reference can be retrieved before and after each location. The value of the reference is printed in this output in the finishing brackets. The notation before the bracket is the notation of a TypedReference ( TypedReference ) Limitations Only String , StringBuilder , and StringBuffer are currently supported. The ParticularValueFactory keeps track of one specific value of a reference. If more values would be possible (e.g., due to a branch), the result will be an UnknownReferenceValue","title":"Data flow analysis with partial evaluation"},{"location":"partialevaluator.html#analyzing-all-instructions","text":"If you want to analyze bytecode, you'll probably want to visit specified instructions of specified code attributes of specified methods of specified classes. The visitor classes and filters quickly get you to the right place: programClassPool . classesAccept ( new AllMethodVisitor ( new AllAttributeVisitor ( new AllInstructionVisitor ( new MyInstructionAnalyzer ())))); You then only need to implement the visitor methods to analyze the instructions: class MyInstructionAnalyzer implements InstructionVisitor { public void visitSimpleInstruction ( Clazz clazz , .....) ... public void visitVariableInstruction ( Clazz clazz , .....) ... public void visitConstantInstruction ( Clazz clazz , .....) ... public void visitBranchInstruction ( Clazz clazz , .....) ... public void visitTableSwitchInstruction ( Clazz clazz , .....) ... public void visitLookUpSwitchInstruction ( Clazz clazz , .....) ... } The library already provides classes to analyze the code for you, finding branching information, performing partial evaluation, finding the control flow and data flow, etc, as introduced in the following sections. Complete example: EvaluateReturnValues.java","title":"Analyzing all instructions"},{"location":"partialevaluator.html#branching","text":"You can extract basic information about branches in a method with the class BranchTargetFinder. The results are defined at the instruction level: each instruction is properly labeled as a branch target, branch origin, exception handler, etc. BranchTargetFinder branchTargetFinder = new BranchTargetFinder (); branchTargetFinder . visitCodeAttribute ( clazz , method , codeAttribute ); if ( branchTargetFinder . isBranchOrigin ( offset )) ... if ( branchTargetFinder . isBranchTarget ( offset )) ... Complete example: ApplyPeepholeOptimizations.java","title":"Collecting basic branching information"},{"location":"partialevaluator.html#partial-evaluation","text":"You can extract more information about the code with partial evaluation (often called abstract evaluation or symbolic evaluation). Its analysis provides a global view of the control flow and data flow in a method. The core class is PartialEvaluator. It can work at different levels of precision \u2014 the more abstract, the less precise. You can control the precision with different value factories and different invocation units: A ValueFactory defines the level of detail in representing values like integers or reference types. The values can be very abstract (any primitive integer, a reference to any object) or more precise (the integer 42, or an integer between 0 and 5, or a non-null reference to an instance of java/lang/String). An InvocationUnit defines the values returned from retrieved fields and invoked methods. The values can again be very generic (any integer) or they can also be values that were cached in prior evaluations of the code base. Complete example: EvaluateCode.java, which provides options to analyze code with different levels of precision. It prints out its results in markdown format, which is also used in the examples below.","title":"Partial evaluation"},{"location":"partialevaluator.html#control-flow-analysis","text":"You can set up basic evaluation with a BasicValueFactory and a BasicInvocationUnit: ValueFactory valueFactory = new BasicValueFactory (); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The analysis provides a control flow graph of the instructions in a method. Each instruction is labeled with potential branch targets and branch origins: InstructionOffsetValue branchOrigins = partialEvaluator . branchOrigins ( offset )); InstructionOffsetValue branchTargets = partialEvaluator . branchTargets ( offset )); Complete example: VisualizeControlFlow.java","title":"Control flow analysis"},{"location":"partialevaluator.html#data-flow-analysis","text":"You can also inspect the data flow between the instructions in a method by looking at the stack and the local variables: TracedStack stack = partialEvaluator . getStackAfter ( offset ); TracedVariables variables = partialEvaluator . getVariablesAfter ( offset ); Consider the following code: public static int getAnswer () { int f1 = 6 ; int f2 = 7 ; return f1 * f2 ; } Applying the above partial evaluator to this code yields this overall result: Instruction Stack v0 v1 [0] bipush 6 [0:i] empty empty [2] istore_0 v0 2:i empty [3] bipush 7 [3:i] 2:i empty [5] istore_1 v1 2:i 5:i [6] iload_0 v0 [6:i] 2:i 5:i [7] iload_1 v1 [6:i] [7:i] 2:i 5:i [8] imul [8:i] 2:i 5:i [9] ireturn 2:i 5:i Each integer value followed by a colon indicates the offset of the instruction that stored or pushed the value. Each 'i' indicates an unknown primitive integer value. Useful applications: dependency analysis at an instruction level, for example to remove unused instructions. Complete example: EvaluateCode.java","title":"Data flow analysis"},{"location":"partialevaluator.html#numerical","text":"The above basic evaluation doesn't tell you much about any numerical results. You can set up more precise numerical evaluation with a ParticularValueFactory: ValueFactory valueFactory = new ParticularValueFactory ( new BasicValueFactory ()); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); For the same code as in the previous section: Instruction Stack v0 v1 [0] bipush 6 [0:6] empty empty [2] istore_0 v0 2:6 empty [3] bipush 7 [3:7] 2:6 empty [5] istore_1 v1 2:6 5:7 [6] iload_0 v0 [6:6] 2:6 5:7 [7] iload_1 v1 [6:6] [7:7] 2:6 5:7 [8] imul [8:42] 2:6 5:7 [9] ireturn 2:6 5:7 In this trivial example, the previously unknown integers are now all concrete values. The last instruction pops the computed result 42 from the stack and returns it. Useful application: constant propagation.","title":"More precise numerical evaluation"},{"location":"partialevaluator.html#range","text":"Consider the following code: public static int getAnswer () { int answer = 0 ; for ( int counter = 0 ; counter < 3 && Math . random () < 0.5f ; counter ++ ) { answer += 14 ; } return answer ; } The possible answer isn't a single value. You can let the evaluation work with integer ranges with a RangeValueFactory: ValueFactory valueFactory = new RangeValueFactory ( new ArrayReferenceValueFactory (), new BasicValueFactory ()); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The overall result of the analysis of the sample method is: Instruction Stack v0 v1 [0] iconst_0 [0:0] empty empty [1] istore_0 v0 1:0 empty [2] iconst_0 [2:0] 1:0 empty [3] istore_1 v1 1:0 3:0 [4] iload_1 v1 [4:0..3] 1,19:0..42 3,22:0..3 [5] iconst_3 [4:0..3] [5:3] 1,19:0..42 3,22:0..3 [6] if_icmpge +22 (target=28) 1,19:0..42 3,22:0..3 [9] invokestatic #2 [9:T] [9:d] 1,19:0..28 3,22:0..2 [12] ldc2_w #3 [9:T] [9:d] [12:T] [12:0.5d] 1,19:0..28 3,22:0..2 [15] dcmpg [15:i] 1,19:0..28 3,22:0..2 [16] ifge +12 (target=28) 1,19:0..28 3,22:0..2 [19] iinc v0, 14 19:14..42 3,22:0..2 [22] iinc v1, 1 19:14..42 22:1..3 [25] goto -21 (target=4) 19:14..42 22:1..3 [28] iload_0 v0 [28:0..42] 1,19:0..42 3,22:0..3 [29] ireturn 1,19:0..42 3,22:0..3 Not all values are entirely concrete; they can have a range (with \"..\"). The method can return a value between 0 and 42. Useful applications: simplification of range checks.","title":"Evaluation with numeric ranges"},{"location":"partialevaluator.html#symbolic","text":"Consider the following code: private static int getAnswer ( int a , int b ) { return 2 * a + b ; } The numerical evaluation of the previous sections doesn't get you very far, since the parameters are unknown, so all computations produce unknown values: Instruction Stack v0 v1 [0] iconst_2 [0:2] P0:i P1:i [1] iload_0 v0 [0:2] [1:i] P0:i P1:i [2] imul [2:i] P0:i P1:i [3] iload_1 v1 [2:i] [3:i] P0:i P1:i [4] iadd [4:i] P0:i P1:i [5] ireturn P0:i P1:i You can set up symbolic evaluation with an IdentifiedValueFactory: ValueFactory valueFactory = new IdentifiedValueFactory (); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The overall result of the analysis of the sample method is: Instruction Stack v0 v1 [0] iconst_2 [0:2] P0:i0 P1:i1 [1] iload_0 v0 [0:2] [1:i0] P0:i0 P1:i1 [2] imul [2:(2*i0)] P0:i0 P1:i1 [3] iload_1 v1 [2:(2*i0)] [3:i1] P0:i0 P1:i1 [4] iadd [4:((2*i0)+i1)] P0:i0 P1:i1 [5] ireturn P0:i0 P1:i1 The unknown values now have symbolic names (IDs): \"i0\" and \"i1\". Any computations result in symbolic expressions, such as \"((2*i0)+i1)\". Useful applications: a basis for symbolic simplification, static single assignment, further analysis with SMT solvers (satisfiability modulo theories).","title":"Symbolic numerical evaluation"},{"location":"partialevaluator.html#tracing","text":"The previous sections only showed examples with primitive types. Consider the following code with reference types: public static Number getAnswer ( Number answer ) { if ( answer == null ) { answer = new Integer ( 42 ); } return answer ; } The basic or numeric evaluation of the previuous sections don't tell much about the non-primitive types: Instruction Stack v0 [0] aload_0 v0 [0:a] P0:a [1] ifnonnull +13 (target=14) P0:a [4] new #2 [4:a] P0:a [7] dup [4:7:a] [4:7:a] P0:a [8] bipush 42 [4:7:a] [4:7:a] [8:42] P0:a [10] invokespecial #3 [4:7:a] P0:a [13] astore_0 v0 13:a [14] aload_0 v0 [14:a] P0,13:a [15] areturn P0,13:a Unknown reference types are shown as \"a\". You can keep track of origins of references in more detail with a ReferenceTracingValueFactory and a ReferenceTracingInvocationUnit. The PartialEvaluator is set up slightly differently from the earlier examples: ReferenceTracingValueFactory valueFactory = new ReferenceTracingValueFactory ( new BasicValueFactory ()) : InvocationUnit invocationUnit = new ReferenceTracingInvocationUnit ( new BasicInvocationUnit ( valueFactory )); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false , valueFactory ); The results then show the origins of non-primitive types: Instruction Stack v0 [0] aload_0 v0 [0:P0:a] P0:P0:a [1] ifnonnull +13 (target=14) P0:P0:a [4] new #2 [4:N4:a] P0:P0:a [7] dup [4:7:N4:a] [4:7:N4:a] P0:P0:a [8] bipush 42 [4:7:N4:a] [4:7:N4:a] [8:i] P0:P0:a [10] invokespecial #3 [4:7:N4:a] P0:P0:a [13] astore_0 v0 13:N4:a [14] aload_0 v0 [14:N4,P0:a] P0,13:N4,P0:a [15] areturn P0,13:N4,P0:a For example, the method pops and returns either a new instance (\"N4\") that was created at offset 4, or parameter 0 (\"P0\"). Useful applications: define/use analysis, a basis for escape analysis or taint analysis.","title":"Evaluation with reference types"},{"location":"partialevaluator.html#typed","text":"You can keep track of non-primitive types in more detail with a TypedReferenceValueFactory: ValueFactory valueFactory = new TypedReferenceValueFactory (); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The results then show the types: Instruction Stack v0 [0] aload_0 v0 [0:Ljava/lang/Number;] P0:Ljava/lang/Number; [1] ifnonnull +13 (target=14) P0:Ljava/lang/Number; [4] new #2 [4:Ljava/lang/Integer;=!] P0:Ljava/lang/Number; [7] dup [4:7:Ljava/lang/Integer;=!] [4:7:Ljava/lang/Integer;=!] P0:Ljava/lang/Number; [8] bipush 42 [4:7:Ljava/lang/Integer;=!] [4:7:Ljava/lang/Integer;=!] [8:i] P0:Ljava/lang/Number; [10] invokespecial #3 [4:7:Ljava/lang/Integer;=!] P0:Ljava/lang/Number; [13] astore_0 v0 13:Ljava/lang/Integer;=! [14] aload_0 v0 [14:Ljava/lang/Number;] P0,13:Ljava/lang/Number; [15] areturn P0,13:Ljava/lang/Number; The types here are \"Ljava/lang/Number;\" and \"Ljava/lang/Integer;\". The types respect the type hierarchy, for example when the branches join and the type is \"Ljava/lang/Number;\". A mark \"=\" means that the type is the exact type, not an extension. A mark \"!\" means that the value is definitely not null. Useful applications: preverification of the type safety of bytecode.","title":"Evaluation with more precise reference types"},{"location":"partialevaluator.html#note-on-type-variables-naming-convention","text":"PGC has different representation for type string variables: External class name: com.guardsquare.SomeClass Internal class name: com/guardsquare/SomeClass Internal type (or just type ): Lcom/guardsquare/SomeClass; (for arrays e.g. [I , [Ljava/lang/Object; ) Internal class type: com/guardsquare/SomeClass (for arrays this is their internal type e.g. [I , [Ljava/lang/Object; ) See proguard.classfile.util.ClassUtil for useful methods to convert between the different representations.","title":"Note on type variables naming convention"},{"location":"partialevaluator.html#array","text":"Primitive arrays may be of special interest, for example when performing optimizations. Consider the following code: public static int getAnswer () { int [] array = new int [] { 6 , 7 }; return array [ 0 ] * array [ 1 ] ; } Even though this is a trivial example, the previous evaluations wouldn't provide much useful information: Instruction Stack v0 [0] iconst_2 [0:i] empty [1] newarray 10 [1:[I?=![i]] empty [3] dup [1:3:[I?=![i]] [1:3:[I?=![i]] empty [4] iconst_0 [1:3:[I?=![i]] [1:3:[I?=![i]] [4:i] empty [5] bipush 6 [1:3:[I?=![i]] [1:3:[I?=![i]] [4:i] [5:i] empty [7] iastore [1:3:[I?=![i]] empty [8] dup [1:8:[I?=![i]] [1:8:[I?=![i]] empty [9] iconst_1 [1:8:[I?=![i]] [1:8:[I?=![i]] [9:i] empty [10] bipush 7 [1:8:[I?=![i]] [1:8:[I?=![i]] [9:i] [10:i] empty [12] iastore [1:8:[I?=![i]] empty [13] astore_0 v0 13:[I?=![i] [14] aload_0 v0 [14:[I?=![i]] 13:[I?=![i] [15] iconst_0 [14:[I?=![i]] [15:i] 13:[I?=![i] [16] iaload [16:i] 13:[I?=![i] [17] aload_0 v0 [16:i] [17:[I?=![i]] 13:[I?=![i] [18] iconst_1 [16:i] [17:[I?=![i]] [18:i] 13:[I?=![i] [19] iaload [16:i] [19:i] 13:[I?=![i] [20] imul [20:i] 13:[I?=![i] [21] ireturn 13:[I?=![i] The array type is \"[I\", which is the standard notation for an array of primitive integers. You can keep track of the lengths of arrays with ArrayReferenceValueFactory and even of the contents of primitive arrays with DetailedArrayValueFactory: ValueFactory valueFactory = new DetailedArrayValueFactory (); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The results of the evaluation then become: Instruction Stack v0 [0] iconst_2 [0:2] empty [1] newarray 10 [1:[I?=![2]#0 empty [3] dup [1:3:[I?=![2]#0 empty [4] iconst_0 [1:3:[I?=![2]#0 empty [5] bipush 6 [1:3:[I?=![2]#0 empty [7] iastore [1:3:[I?=![2]#0 empty [8] dup [1:8:[I?=![2]#0 empty [9] iconst_1 [1:8:[I?=![2]#0 empty [10] bipush 7 [1:8:[I?=![2]#0 empty [12] iastore [1:8:[I?=![2]#0 empty [13] astore_0 v0 13:[I?=![2]#0 [14] aload_0 v0 [14:[I?=![2]#0 13:[I?=![2]#0 [15] iconst_0 [14:[I?=![2]#0 13:[I?=![2]#0 [16] iaload [16:6] 13:[I?=![2]#0 [17] aload_0 v0 [16:6] [17:[I?=![2]#0 13:[I?=![2]#0 [18] iconst_1 [16:6] [17:[I?=![2]#0 13:[I?=![2]#0 [19] iaload [16:6] [19:7] 13:[I?=![2]#0 [20] imul [20:42] 13:[I?=![2]#0 [21] ireturn 13:[I?=![2]#0 The array is now traced as having length 2 and elements 6 and 7. Useful application: simplification of code with enum types.","title":"Evaluation with primitive arrays"},{"location":"partialevaluator.html#particularreference","text":"The values of references can also be of interest. Consider the following code: public StringBuilder append () { StringBuilder s = new StringBuilder ( \"asd\" ); s . append ( \"fgh\" ); return s ; } If the value of s is of interest, this can be retrieved using a ParticularValueFactory . To also keep track of the references as they flow through method calls (in the example: the constructor-call, and the append ), the InvocationUnit needs to be a ExecutingInvocationUnit : ValueFactory valueFactory = new ParticularValueFactory ( new BasicValueFactory (), new ParticularValueFactory . ReferenceValueFactory ()); ExecutingInvocationUnit invocationUnit = new ExecutingInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The results of the evaluation then become: Instruction Stack (before the Instruction) v0 (before the Instruction) [0] new StringBuilder [empty:empty] [3] dup [0:StringBuilder=!#0] [empty:empty] [4] ldc \"asd\" [3:0:StringBuilder=!#0] [3:0:StringBuilder=!#0] [empty:empty] [6] invokespecial StringBuilder.<init>(String)V [4:String?=#1(asd)] [3:0:StringBuilder=!#0] [3:0:StringBuilder=!#0] [empty:empty] [9] astore_0 v0 [3:0:StringBuilder=#2(asd)] [empty:empty] [10] aload_0 v0 [9:StringBuilder=#2(asd)] [11] ldc \"fgh\" [10:StringBuilder=#2(asd)] [9:StringBuilder=#2(asd)] [13] invokevirtual StringBuilder.append(String)StringBuilder [11:String?=#3(fgh)] [10:StringBuilder=#2(asd)] [9:StringBuilder=#2(asd)] [16] pop [13:StringBuilder=#4(asdfgh)] [13:StringBuilder=#4(asdfgh)] [17] aload_0 v0 [13:StringBuilder=#4(asdfgh)] [18] areturn [17:StringBuilder=#4(asdfgh)] [13:StringBuilder=#4(asdfgh)] (Class/String constants are added to the instruction, and java/lang/ is ommited from the class names for clarity) The StringBuilder is now traced through the method, the value of the reference can be retrieved before and after each location. The value of the reference is printed in this output in the finishing brackets. The notation before the bracket is the notation of a TypedReference ( TypedReference )","title":"Evaluation with particular reference values"},{"location":"partialevaluator.html#limitations","text":"Only String , StringBuilder , and StringBuffer are currently supported. The ParticularValueFactory keeps track of one specific value of a reference. If more values would be possible (e.g., due to a branch), the result will be an UnknownReferenceValue","title":"Limitations"},{"location":"patternmatching.html","text":"Basic pattern matching The library has powerful support to match patterns in bytecode instruction sequences. You first define the pattern as a sequence of instructions, with wildcards. For example: final int X = InstructionSequenceMatcher . X ; final int C = InstructionSequenceMatcher . C ; InstructionSequenceBuilder ____ = new InstructionSequenceBuilder (); Instruction [] pattern = ____ . iload ( X ) . bipush ( C ) . istore ( X ). __ (); Constant [] constants = ____ . constants (); You can then find that pattern in given code: programClassPool . classesAccept ( new AllMethodVisitor ( new AllAttributeVisitor ( new AllInstructionVisitor ( new MyMatchPrinter ( new InstructionSequenceMatcher ( constants , pattern )))))); Complete example: ApplyPeepholeOptimizations.java Replacing patterns Instead of just matching instruction sequences, you can also replace matched sequences by other instruction sequences, for example to optimize code or instrument code. The core classes are PeepholeEditor and InstructionSequenceReplacer. Say that you want to replace an instruction sequence \"putstatic/getstatic\" by an equivalent \"dup/putstatic\": final int X = InstructionSequenceReplacer . X ; InstructionSequenceBuilder ____ = new InstructionSequenceBuilder (); Instruction [][] replacements = { ____ . putstatic ( X ) . getstatic ( X ). __ (), ____ . dup () . putstatic ( X ). __ () }; Constant [] constants = ____ . constants (); BranchTargetFinder branchTargetFinder = new BranchTargetFinder (); CodeAttributeEditor codeAttributeEditor = new CodeAttributeEditor (); programClassPool . classesAccept ( new AllMethodVisitor ( new AllAttributeVisitor ( new PeepholeEditor ( branchTargetFinder , codeAttributeEditor , new InstructionSequenceReplacer ( constants , replacements [ 0 ] , constants , replacements [ 1 ] , branchTargetFinder , codeAttributeEditor ))))); You can define multiple patterns and their respective replacements in one go, with the wrapper InstructionSequencesReplacer. Complete example: ApplyPeepholeOptimizations.java","title":"Pattern matching"},{"location":"patternmatching.html#basic-pattern-matching","text":"The library has powerful support to match patterns in bytecode instruction sequences. You first define the pattern as a sequence of instructions, with wildcards. For example: final int X = InstructionSequenceMatcher . X ; final int C = InstructionSequenceMatcher . C ; InstructionSequenceBuilder ____ = new InstructionSequenceBuilder (); Instruction [] pattern = ____ . iload ( X ) . bipush ( C ) . istore ( X ). __ (); Constant [] constants = ____ . constants (); You can then find that pattern in given code: programClassPool . classesAccept ( new AllMethodVisitor ( new AllAttributeVisitor ( new AllInstructionVisitor ( new MyMatchPrinter ( new InstructionSequenceMatcher ( constants , pattern )))))); Complete example: ApplyPeepholeOptimizations.java","title":"Basic pattern matching"},{"location":"patternmatching.html#replacing-patterns","text":"Instead of just matching instruction sequences, you can also replace matched sequences by other instruction sequences, for example to optimize code or instrument code. The core classes are PeepholeEditor and InstructionSequenceReplacer. Say that you want to replace an instruction sequence \"putstatic/getstatic\" by an equivalent \"dup/putstatic\": final int X = InstructionSequenceReplacer . X ; InstructionSequenceBuilder ____ = new InstructionSequenceBuilder (); Instruction [][] replacements = { ____ . putstatic ( X ) . getstatic ( X ). __ (), ____ . dup () . putstatic ( X ). __ () }; Constant [] constants = ____ . constants (); BranchTargetFinder branchTargetFinder = new BranchTargetFinder (); CodeAttributeEditor codeAttributeEditor = new CodeAttributeEditor (); programClassPool . classesAccept ( new AllMethodVisitor ( new AllAttributeVisitor ( new PeepholeEditor ( branchTargetFinder , codeAttributeEditor , new InstructionSequenceReplacer ( constants , replacements [ 0 ] , constants , replacements [ 1 ] , branchTargetFinder , codeAttributeEditor ))))); You can define multiple patterns and their respective replacements in one go, with the wrapper InstructionSequencesReplacer. Complete example: ApplyPeepholeOptimizations.java","title":"Replacing patterns"},{"location":"reading.html","text":"Streaming classes from a jar file You can read classes from class files and various types of (nested) jar files or jmod files, with some convenient utility classes and visitors. For example, you can read all classes from all jar files in a given directory and print them out in a streaming fashion, while they are read, without collecting their representations: DataEntrySource source = new DirectorySource ( new File ( inputDirectoryName )); source . pumpDataEntries ( new FilteredDataEntryReader ( new DataEntryNameFilter ( new ExtensionMatcher ( \".jar\" )), new JarReader ( new ClassFilter ( new ClassReader ( false , false , false , false , null , new ClassPrinter ()))))); Note the constructor-based dependency injection, to create a chain of visitor classes. We typically use a slightly unconventional indentation to make this construct easy to read. Complete example: PrintClasses.java Streaming classes from a dex/apk file With the addition of proguard-core-android , you can read classes from dex/apk files just like you would with jar files. A small example showing how to use DexClassReader() to read classes from a dex/apk file: DataEntrySource source = new DirectorySource ( new File ( inputDirectoryName )); DataEntryReader classReader = new NameFilteredDataEntryReader ( \"**.class\" , new ClassReader ( false , false , false , false , null , new ClassNameFilter ( \"**\" , null ))); // Convert dex files to a jar first classReader = new NameFilteredDataEntryReader ( \"classes*.dex\" , new DexClassReader ( true , new ClassPrinter ()), classReader ); source . pumpDataEntries ( classReader ); Do note that in order to use dex/apk file reading functionalities within your project, you must import proguard-core-android in the build.gradle file: build.gradle dependencies { ... implementation project('com.guardsquare:proguard-core') implementation project('com.guardsquare:proguard-core-android') ... } Writing out streamed classes You can read classes, optionally perform some small modifications, and write them out right away, again in a streaming fashion. JarWriter jarWriter = new JarWriter ( new ZipWriter ( new FixedFileWriter ( new File ( outputJarFileName )))); DataEntrySource source = new FileSource ( new File ( inputJarFileName )); source . pumpDataEntries ( new JarReader ( new ClassFilter ( new ClassReader ( false , false , false , false , null , new DataEntryClassWriter ( jarWriter ))))); jarWriter . close (); Complete example: ApplyPeepholeOptimizations.java Collecting classes Alternatively, you may want to collect the classes in a so-called class pool first, so you can perform more extensive analyses on them: ClassPool classPool = new ClassPool (); DataEntrySource source = new FileSource ( new File ( jarFileName )); source . pumpDataEntries ( new JarReader ( false , new ClassFilter ( new ClassReader ( false , false , false , false , null , new ClassPoolFiller ( classPool ))))); Complete example: Preverify.java Writing out a set of classes If you've collected a set of classes in a class pool, you can write them out with the same visitors as before. JarWriter jarWriter = new JarWriter ( new ZipWriter ( new FixedFileWriter ( new File ( outputJarFileName )))); classPool . classesAccept ( new DataEntryClassWriter ( jarWriter )); jarWriter . close (); Complete example: Preverify.java","title":"Reading classes"},{"location":"reading.html#streaming-classes-from-a-jar-file","text":"You can read classes from class files and various types of (nested) jar files or jmod files, with some convenient utility classes and visitors. For example, you can read all classes from all jar files in a given directory and print them out in a streaming fashion, while they are read, without collecting their representations: DataEntrySource source = new DirectorySource ( new File ( inputDirectoryName )); source . pumpDataEntries ( new FilteredDataEntryReader ( new DataEntryNameFilter ( new ExtensionMatcher ( \".jar\" )), new JarReader ( new ClassFilter ( new ClassReader ( false , false , false , false , null , new ClassPrinter ()))))); Note the constructor-based dependency injection, to create a chain of visitor classes. We typically use a slightly unconventional indentation to make this construct easy to read. Complete example: PrintClasses.java","title":"Streaming classes from a jar file"},{"location":"reading.html#streaming-classes-from-a-dexapk-file","text":"With the addition of proguard-core-android , you can read classes from dex/apk files just like you would with jar files. A small example showing how to use DexClassReader() to read classes from a dex/apk file: DataEntrySource source = new DirectorySource ( new File ( inputDirectoryName )); DataEntryReader classReader = new NameFilteredDataEntryReader ( \"**.class\" , new ClassReader ( false , false , false , false , null , new ClassNameFilter ( \"**\" , null ))); // Convert dex files to a jar first classReader = new NameFilteredDataEntryReader ( \"classes*.dex\" , new DexClassReader ( true , new ClassPrinter ()), classReader ); source . pumpDataEntries ( classReader ); Do note that in order to use dex/apk file reading functionalities within your project, you must import proguard-core-android in the build.gradle file: build.gradle dependencies { ... implementation project('com.guardsquare:proguard-core') implementation project('com.guardsquare:proguard-core-android') ... }","title":"Streaming classes from a dex/apk file"},{"location":"reading.html#writing-out-streamed-classes","text":"You can read classes, optionally perform some small modifications, and write them out right away, again in a streaming fashion. JarWriter jarWriter = new JarWriter ( new ZipWriter ( new FixedFileWriter ( new File ( outputJarFileName )))); DataEntrySource source = new FileSource ( new File ( inputJarFileName )); source . pumpDataEntries ( new JarReader ( new ClassFilter ( new ClassReader ( false , false , false , false , null , new DataEntryClassWriter ( jarWriter ))))); jarWriter . close (); Complete example: ApplyPeepholeOptimizations.java","title":"Writing out streamed classes"},{"location":"reading.html#collecting-classes","text":"Alternatively, you may want to collect the classes in a so-called class pool first, so you can perform more extensive analyses on them: ClassPool classPool = new ClassPool (); DataEntrySource source = new FileSource ( new File ( jarFileName )); source . pumpDataEntries ( new JarReader ( false , new ClassFilter ( new ClassReader ( false , false , false , false , null , new ClassPoolFiller ( classPool ))))); Complete example: Preverify.java","title":"Collecting classes"},{"location":"reading.html#writing-out-a-set-of-classes","text":"If you've collected a set of classes in a class pool, you can write them out with the same visitors as before. JarWriter jarWriter = new JarWriter ( new ZipWriter ( new FixedFileWriter ( new File ( outputJarFileName )))); classPool . classesAccept ( new DataEntryClassWriter ( jarWriter )); jarWriter . close (); Complete example: Preverify.java","title":"Writing out a set of classes"},{"location":"releasenotes.html","text":"Version 9.0.8 Improved Increase proguard.classfile.VersionConstants.MAX_SUPPORTED_VERSION to 64.65535 (Java 20 + preview enabled). Fix tracking of IdentifiedReferenceValue IDs. Add new Kotlin visitor SAM interfaces: KotlinClassVisitor , KotlinFileFacadeVisitor , KotlinMultiFileFacadeVisitor , KotlinMultiFilePartVisitor , KotlinSyntheticClassVisitor . API changes JvmTransferRelation has been refactored to model IINC in a separate computeIncrement method. The ProcessingFlag.DONT_PROCESS_KOTLIN_MODULE value was changed from 0x00002000 to 0x00008000 . Remove fromClassPool suffixes in CfaUtil methods. Refactor CodeLocation to only take the signature and offset into consideration. IdentifiedReferenceValue id field changed from int to Object . ParticularValueFactory.ReferenceFactory replaced by ParticularReferenceValueFactory . Add ValueFactory.createReferenceValue(String type, Clazz referencedClass, boolean mayBeExtension, boolean maybeNull, Clazz creationClass, Method creationMethod, int creationOffset) to allow creating references identified by their creation site. Add JvmCfaReferenceValueFactory to create references identified by the JvmCfaNode creation site. Upgrade considerations Identified and particular references can now be identified by any Object instead of a simple int . However, this means that code which compared the IDs may need to be modified. For example, the following code should be changed: public static boolean equal ( IdentifiedReferenceValue a , IdentifiedReferenceValue b ) { return a . id == b . id ; } It should use the equals method instead. public static boolean equal ( IdentifiedReferenceValue a , IdentifiedReferenceValue b ) { return a . id . equals ( b . id ); } The ParticularReferenceValueFactory identifies references with integers by default: ValueFactory valueFactory = new ParticularReferenceFactory ( new ParticularReferenceValueFactory ()); Value a = valueFactory . createReferenceValue ( \"Ljava/lang/String;\" , clazz , false , false ); // a.id will be an integer. Any Object can be used as an ID using the createReferenceValueForId method: String objectId = \"myId\" ; ValueFactory valueFactory = new ParticularReferenceFactory ( new ParticularReferenceValueFactory ()); Value a = valueFactory . createReferenceValueForId ( \"Ljava/lang/String;\" , clazz , false , false , objectId ); // a.id will be objectId Version 9.0.7 Improved Add JvmShallowHeapModel for selective heap modeling. Version 9.0.7 Improved Don't report warnings for missing Kotlin default implementation classes when initializing with ClassReferenceInitializer . Only link matching methods in Kotlin file facades with MethodLinker . Extend the LimitedHashMap parameterization with an element exclusion selector. Add the possibility to add a predicate to taint sources and sinks for selective response to calls. Bug fixes Fix the reduce operator producing a wrong JvmAbstractState for the composite taint analysis. Fix potential expected Precise Reference runtime verifier error. Don't report warnings for missing Kotlin default implementation classes when initiazing with ClassReferenceInitializer . API Improvements Add KotlinMetadataAsserter to check the integrity of Kotlin metadata. Add JvmReturnTaintSink to support return instruction sinks in taint analysis. Use method signatures instead of fully qualified names in taint sources and sinks. API changes JvmTaintSink has been generalized, use JvmInvokeTaintSink to have the old functionalities. Version 9.0.6 Improved Add support for limiting the size of the CPA tree heap model with LimitedHashMap s. Bug fixes Fix ldc_w method in the InstructionSequenceBuilder generating a ldc instruction instead of a ldc_w . API Improvements Add referencedDefaultMethodAccept to KotlinFunctionMetadata model. Version 9.0.5 Improved Replace proguard-assembler dependency in test fixtures with Maven Central version. Bug fixes Do not add interprocedural CFA edges for methods missing intraprocedural CFA. Version 9.0.4 Improved Allow class sub-hierarchy re-initialization for the optimized implementation of ClassSubHierarchyInitializer . Enable providing distinct abort operators for the main and trace reconstruction CPAs. Add a heap model for taint CPA supporting tainting of whole objects. Call API: Add a few utilities and fix inconsistent call argument count getter behavior. Only change the Kotlin metadata version if the original version is unsupported. Add support for Kotlin context receivers in Kotlin metadata. Add support for reading & writing Kotlin 1.8 metadata. API Improvements Add referencedDefaultImplementationMethodAccept to KotlinFunctionMetadata model class. Deprecated referencedMethodAccept(Clazz, MemberVisitor) in favour of referencedMethodAccept(MemberVisitor) in KotlinFunctionMetadata model class. Add TransformedStringMatcher . Add ClassFeatureNameCollector . Add var-arg constructor to ClassPath . Add DataEntryClassInfoFilter . Add NamedDataEntry . Refactor CodeLocation#getClassName as getExternalClassName to comply with the types naming convention. Make TypedReferenceValue.ALLOW_INCOMPLETE_CLASS_HIERARCHY private, add a getter TypedReferenceValue.allowsIncompleteClassHierarchy() instead. Bug fixes Fix side effect on DetailedArrayReferenceValue modifying values at previous offsets on array store instructions during PartialEvaluator execution. Fix JvmTransferRelation to produce a successor in case of missing interprocedural call edge (e.g., in case of incomplete call resolution). Fix call resolution for invokedynamic (issue #63). There might now be calls with incomplete target information. By default, these calls will not be distributed to visitors, but this can be enabled by setting the skipIncompleteCalls option in the call resolver. Fix leading $ being stripped from inner classes by the ClassReferenceFixer . This prevents classes with names like Foo$$Bar incorrectly having their simple name changed from $Bar to Bar . Version 9.0.3 Java support Update maximum supported Java class version to 63.65535 (Java 19 ea). ( PGD-247 ) Improved Add utility to produce dot-graphs for control flow automatons ( CfaUtil.toDot(cfa) , example VisualizeCfa ). Add support for heap slicing on call sites and heap reconstruction on return sites in dataflow analysis heap tree model. Add support for differential map representation to be used in the data flow analysis. API Improvements Split ProgramLocationDependentTransferRelation into forward and backward variants. Add ClassPoolClassLoader utility for loading ProGuardCORE classes. Add builders for CPA runs. Version 9.0.2 Improved JvmMemoryLocationTransferRelation does not rely anymore on a pre-computed abstract reachability graph. Improvements to Kotlin metadata initialization Several improvements to Kotlin metadata initialization now allow building the Kotlin metadata model for library classes ( LibraryClass ): KotlinMetadataInitializer provides a new public method initialize(Clazz, int, int[], String[], String[], int, String, String) to initialize the Kotlin metadata model for a given class. ClassReader can now build the Kotlin metadata model by setting includeKotlinMetadata to true . LibraryClassReader can now read the Kotlin metadata annotation and provide the components to a consumer. An UnsupportedKotlinMetadata type is now assigned by the KotlinMetadataInitializer if the Kotlin metadata model could not be initialized correctly. Version 9.0.1 Improved ExecutingInvocationUnit now loads values from static final fields. Initialize Kotlin lambda method references when the JVM method name is <anonymous> . Add the possibility of limiting the number of CodeAttributes contributing into CFA. Add the possibility of limiting the number of CodeAttributes considered by the CallResolver . Bug fixes Fix wrong handling of array types in ExecutingIvocationUnit and ParticularReferenceValue . ParticularReferenceValue sanity checks now take inheritance into consideration, improving call analysis. Prevent missing semicolon leading to an infinite loop in ClassUtil#internalMethodParameterCount . Make category 2 CPA taint sources affect only the most significant byte abstract state. Fix inconsistent usage of type names in the context of the PartialEvaluator that could result in trying to create an internal type string from a string that was already an internal type. Fix initialization of Kotlin callable references when using -Xno-optimized-callable-references compiler option. Fix createCache() delegation in ArgBamCpaRun Upgrade considerations TYPE NAME CONVENTION PGC has different representation for type string variables: External class name: com.guardsquare.SomeClass Internal class name: com/guardsquare/SomeClass Internal type (or just type ): Lcom/guardsquare/SomeClass; (for arrays e.g. [I , [Ljava/lang/Object; ) Internal class type: com/guardsquare/SomeClass (for arrays this is their internal type e.g. [I , [Ljava/lang/Object; ) See proguard.classfile.util.ClassUtil for useful methods to convert between the different representations. Since internal class name and type were used ambiguously, from version 9.0.1 the internal type is used consistently whenever we have a variable named type . Since this was not the case, this update might cause some type variables switching from the internal class name notation to the internal type notation, potentially breaking some logic if types are used by an external application using proguard-core. Version 9.0 (April 2022) Configurable program analysis (CPA) CPA is a formalism for data flow analysis allowing seamless composition of various analyses and model checking techniques. Thus, it adds a framework for systematic development and extension of static analyses in a uniform structured way. Taint analysis is the first ProGuardCORE CPA. Its goal is to detect data flow between source and sink method calls, which is useful for detecting bugs and security flaws. The Taint Analysis manual page provides more information. Add configurable program analysis (CPA) for interprocedural data flow analysis development. Add taint analysis. Bug fixes Prevent linking a final method with a shadowing method in a subclass. Force Call#getArgumentCount() to be correct even if the actual argument values could not be calculated or have been cleared. Reset ExecutingInvocationUnit parameters array even when an exception happens. Version 8.0.7 Java support Update maximum supported Java class version to 62.65535 (Java 18 ea). Improved Add support for Kotlin property synthetic delegate methods. Add ability to pass KotlinMetadataVersion to KotlinMetadataWriter / KotlinModuleWriter . Version 8.0.6 Improved Add support for writing out zip64 archives. Improve speed for ClassPool.contains method. Version 8.0.5 Improved Upgrade log4j2 dependency to v2.17.1 in response to CVE-2021-44832. Add support for reading and writing Kotlin 1.6 metadata. Bug fixes Fix CallResolver erroneously creating call edges to unimplemented interface methods. Make the DominatorCalculator skip methods with an empty CodeAttribute . Prevent updating Kotlin function names with mangled JVM method names in ClassReferenceFixer . Initialize Kotlin default implementation classes of annotation classes correctly in ClassReferenceInitializer . Correctly initialize Java Record component attributes in ClassReferenceInitializer . API changes KotlinInterfaceToDefaultImplsClassVisitor replaced by KotlinClassToDefaultImplsClassVisitor . Deprecate Kotlin class metadata flag IS_INLINE and replaced with IS_VALUE . Convert to/from Kotlin unsigned integers in Kotlin annotation unsigned type arguments. Initialize array dimension in Kotlin annotation ClassValue type arguments. Add support for Kotlin inline class underlying type to Kotlin metadata model. Add support to MemberDescriptorReferencedClassVisitor for visiting referenced Kotlin inline class parameters. Version 8.0.4 Improved Upgrade log4j2 dependency to v2.17 in response to CVE-2021-45105. API Improvements Add KotlinMetadataVersionFilter to filter classes based on the version of the attached metadata. Version 8.0.3 Improved Upgrade log4j2 dependency in response to CVE-2021-45046. Version 8.0.2 Improved Upgrade log4j2 dependency in response to CVE-2021-44228. API Improvements Add call resolving and graph traversal features to enable interprocedural control flow analyses. Bug fixes Fix potential StringIndexOutOfBoundsException while trimming attribute value spaces in SignedJarWriter . Fix referencedClass of Values generated by the ExecutingInvocationUnit . Fix potential StackOverflowError when using an AttributeVisitor to visit runtime invisible type annotations. Fix potential StringIndexOutOfBoundsException in KotlinCallableReferenceInitializer . Fix potential NullPointerException in KotlinInterClassPropertyReferenceInitializer . Fix wrong offset for complementary branch instruction when widening branch instructions in InstructionWriter . Fix potential ClassFormatError due to adding multiple annotation attributes when processing Kotlin code. Fix potential NullPointerException due to missing classes in ClassReferenceInitializer . Prevent making package-private final methods that are shadowed protected. Version 8.0.1 API Improvements Add LibraryClassBuilder and LibraryClassEditor classes to create and edit a LibraryClass . Add additional constructors to LibraryClass . Bug fixes Fix potential NullPointerException when initializing Kotlin callable references. Prevent requiring --enable-preview on a JVM for Java 16 class files (write class file version 60.0 instead of 60.65535 ). Fix potential NullPointerException when visiting referenced methods of Kotlin functions. Version 8.0.0 Java support Update maximum supported Java class version to 61.0 (Java 17). Kotlin support Add support for processing Kotlin 1.5 metadata. Update kotlinx metadata dependency to version 0.2. API Improvements Add WarningLogger class to allow using a custom Log4j2 logger. Add Kotlin metadata model classes and visitors for Kotlin annotations. Add Kotlin metadata model enum for KmVariance . Add Kotlin metadata model enum for KmVersionRequirement(Kind|Level) . Add Kotlin metadata model enum for KmEffect(Type|InvocationKind) . Add Kotlin metadata flag IS_FUN for functional interfaces. Add Kotlin metadata flag HAS_NON_STABLE_PARAMETER_NAMES for Kotlin callables. Add error handler callback to KotlinMetadataInitializer . Add error handler callback to KotlinMetadataWriter . Add error handler callback to KotlinModuleReader . Add error handler callback to KotlinModuleWriter . Add Kotlin metadata flag IS_SECONDARY for constructors. Implement ClassVisitor in KotlinMetadataInitializer to allow easier initialization of Kotlin metadata. Implement ClassVisitor in KotlinMetadataWriter to allow easier writing of Kotlin metadata. API changes KotlinTypeParameterVistor#visitClassParameter(Clazz, KotlinMetadata, KotlinTypeParameterMetadata) now has the correct signature: KotlinTypeParameterVistor#visitClassParameter(Clazz, KotlinClassKindMetadata, KotlinTypeParameterMetadata) . Rename AllKotlinPropertiesVisitor to AllPropertyVisitor . Rename AllConstructorsVisitor to AllConstructorVisitor . Rename AllFunctionsVisitor to AllFunctionVisitor . Remove `KotlinValueParameterVisitor.onNewFunctionStart()' method. Deprecate Kotlin metadata flag IS_PRIMARY for constructors. Version 7.1.1 API improvements Add KotlinTypeParameterFilter to allow filtering easily when visiting type parameters. Add KotlinValueParameterFilter to allow filtering easily when visiting value parameters. Bug fixes Fix AllTypeParameterVisitor so that it visits type parameters defined in any kind of declaration container. Fix AllTypeParameterVisitor so that it visits type parameters of type aliases. Fix potential NullPointerException when initializing a Kotlin default implementation class that does not contain an initialized jvmSignature . Add missing equals method to ParticularReferenceValue . Fix incorrect handling of InterruptedException in ParallelAllClassVisitor . Fix potential ZipOutput alignment issue when writing large uncompressed zip entries. Fix potential ZipOutput synchronization issue when writing uncompressed zip entries. Fix potential NullPointerException when comparing strings with FixedStringMatcher . Fix potential NullPointerException when comparing strings with MatchedStringMatcher . Fix initialization of Kotlin callable references when using Kotlin >= 1.4. Version 7.1 (June 2021) Java support ProGuardCORE 7.1 now supports Java versions 14, 15 and 16: Add support for reading & writing Java 14, 15 and 16 class files. Add support for Java 14 sealed classes (permitted subclasses attributes). Add support for record attributes (previewed in Java 15/16, targeted for Java 17). Improved code analysis The partial evaluator can now be used to reconstruct the specific values of String , StringBuilder and StringBuffer type objects. See analyzing code manual page for more information. The partial evaluator will now throw an IncompleteClassHierarchyException instead of IllegalArgumentException when an incomplete hierarchy is encountered. The partial evaluator will now throw an ExcessiveComplexityException if an instruction is visited more than stopAnalysisAfterNEvaluations times. Potentially throwing ldc instructions are now taken into account during partial evaluation, improving the accuracy of code analysis. Add support for multiple possible types during partial evaluation. Performance improvements Improve efficiency of building classes, methods and constant pools. API improvements Add ClassRenamer to allow renaming classes and members easily. Bug fixes Add missing method reference in injected static initializer instructions. Add missing dimensions argument to CompactCodeAttributeComposer.multianewarray . Fix potential StackOverflowException when comparing multi-typed reference values. Fix handling of Kotlin nested class names which contain $ . Mark Module , ModuleMainClass and ModulePackages attributes as required. Fix potential ClassCastException in ConstructorMethodFilter . Fix potential NullPointerException for module classes in ClassPrinter. Fix storage and alignment of uncompressed zip entries. Fix processing of constant boolean arrays. Fix adding branch instructions with labels in CompactCodeAttributeComposer . Fix handling of array dereferencing in MultiTypedReferenceValue . Fix AllKotlinAnnotationVisitor so that it visits type alias annotations defined in any kind of declaration container. Move initialization of Kotlin declaration container's ownerClassName field from ClassReferenceInitializer to KotlinMetadataInitializer . Version 7.0 (Jan 2020) Version Issue Module Explanation 7.0.1 DGD-2382 CORE Fixed processing of Kotlin 1.4 metadata annotations. 7.0.1 DGD-2390 CORE Fixed storage and alignment of uncompressed zip entries. 7.0.1 DGD-2338 CORE Fixed processing of constant boolean arrays. 7.0.1 CORE Fixed adding branch instructions with labels in CompactCodeAttributeComposer. 7.0.0 CORE Initial release of Kotlin support. 7.0.0 PGD-32 CORE Added support for Java 14 class files. 7.0.0 DGD-1780 CORE Removed dependency on internal sun.security API. 7.0.0 DGD-1800 CORE Fixed obfuscation of functional interfaces with abstract Object methods. 7.0.0 CORE Initial release, extracted from ProGuard.","title":"Release notes"},{"location":"releasenotes.html#version-908","text":"","title":"Version 9.0.8"},{"location":"releasenotes.html#improved","text":"Increase proguard.classfile.VersionConstants.MAX_SUPPORTED_VERSION to 64.65535 (Java 20 + preview enabled). Fix tracking of IdentifiedReferenceValue IDs. Add new Kotlin visitor SAM interfaces: KotlinClassVisitor , KotlinFileFacadeVisitor , KotlinMultiFileFacadeVisitor , KotlinMultiFilePartVisitor , KotlinSyntheticClassVisitor .","title":"Improved"},{"location":"releasenotes.html#api-changes","text":"JvmTransferRelation has been refactored to model IINC in a separate computeIncrement method. The ProcessingFlag.DONT_PROCESS_KOTLIN_MODULE value was changed from 0x00002000 to 0x00008000 . Remove fromClassPool suffixes in CfaUtil methods. Refactor CodeLocation to only take the signature and offset into consideration. IdentifiedReferenceValue id field changed from int to Object . ParticularValueFactory.ReferenceFactory replaced by ParticularReferenceValueFactory . Add ValueFactory.createReferenceValue(String type, Clazz referencedClass, boolean mayBeExtension, boolean maybeNull, Clazz creationClass, Method creationMethod, int creationOffset) to allow creating references identified by their creation site. Add JvmCfaReferenceValueFactory to create references identified by the JvmCfaNode creation site.","title":"API changes"},{"location":"releasenotes.html#upgrade-considerations","text":"Identified and particular references can now be identified by any Object instead of a simple int . However, this means that code which compared the IDs may need to be modified. For example, the following code should be changed: public static boolean equal ( IdentifiedReferenceValue a , IdentifiedReferenceValue b ) { return a . id == b . id ; } It should use the equals method instead. public static boolean equal ( IdentifiedReferenceValue a , IdentifiedReferenceValue b ) { return a . id . equals ( b . id ); } The ParticularReferenceValueFactory identifies references with integers by default: ValueFactory valueFactory = new ParticularReferenceFactory ( new ParticularReferenceValueFactory ()); Value a = valueFactory . createReferenceValue ( \"Ljava/lang/String;\" , clazz , false , false ); // a.id will be an integer. Any Object can be used as an ID using the createReferenceValueForId method: String objectId = \"myId\" ; ValueFactory valueFactory = new ParticularReferenceFactory ( new ParticularReferenceValueFactory ()); Value a = valueFactory . createReferenceValueForId ( \"Ljava/lang/String;\" , clazz , false , false , objectId ); // a.id will be objectId","title":"Upgrade considerations"},{"location":"releasenotes.html#version-907","text":"","title":"Version 9.0.7"},{"location":"releasenotes.html#improved_1","text":"Add JvmShallowHeapModel for selective heap modeling.","title":"Improved"},{"location":"releasenotes.html#version-907_1","text":"","title":"Version 9.0.7"},{"location":"releasenotes.html#improved_2","text":"Don't report warnings for missing Kotlin default implementation classes when initializing with ClassReferenceInitializer . Only link matching methods in Kotlin file facades with MethodLinker . Extend the LimitedHashMap parameterization with an element exclusion selector. Add the possibility to add a predicate to taint sources and sinks for selective response to calls.","title":"Improved"},{"location":"releasenotes.html#bug-fixes","text":"Fix the reduce operator producing a wrong JvmAbstractState for the composite taint analysis. Fix potential expected Precise Reference runtime verifier error. Don't report warnings for missing Kotlin default implementation classes when initiazing with ClassReferenceInitializer .","title":"Bug fixes"},{"location":"releasenotes.html#api-improvements","text":"Add KotlinMetadataAsserter to check the integrity of Kotlin metadata. Add JvmReturnTaintSink to support return instruction sinks in taint analysis. Use method signatures instead of fully qualified names in taint sources and sinks.","title":"API Improvements"},{"location":"releasenotes.html#api-changes_1","text":"JvmTaintSink has been generalized, use JvmInvokeTaintSink to have the old functionalities.","title":"API changes"},{"location":"releasenotes.html#version-906","text":"","title":"Version 9.0.6"},{"location":"releasenotes.html#improved_3","text":"Add support for limiting the size of the CPA tree heap model with LimitedHashMap s.","title":"Improved"},{"location":"releasenotes.html#bug-fixes_1","text":"Fix ldc_w method in the InstructionSequenceBuilder generating a ldc instruction instead of a ldc_w .","title":"Bug fixes"},{"location":"releasenotes.html#api-improvements_1","text":"Add referencedDefaultMethodAccept to KotlinFunctionMetadata model.","title":"API Improvements"},{"location":"releasenotes.html#version-905","text":"","title":"Version 9.0.5"},{"location":"releasenotes.html#improved_4","text":"Replace proguard-assembler dependency in test fixtures with Maven Central version.","title":"Improved"},{"location":"releasenotes.html#bug-fixes_2","text":"Do not add interprocedural CFA edges for methods missing intraprocedural CFA.","title":"Bug fixes"},{"location":"releasenotes.html#version-904","text":"","title":"Version 9.0.4"},{"location":"releasenotes.html#improved_5","text":"Allow class sub-hierarchy re-initialization for the optimized implementation of ClassSubHierarchyInitializer . Enable providing distinct abort operators for the main and trace reconstruction CPAs. Add a heap model for taint CPA supporting tainting of whole objects. Call API: Add a few utilities and fix inconsistent call argument count getter behavior. Only change the Kotlin metadata version if the original version is unsupported. Add support for Kotlin context receivers in Kotlin metadata. Add support for reading & writing Kotlin 1.8 metadata.","title":"Improved"},{"location":"releasenotes.html#api-improvements_2","text":"Add referencedDefaultImplementationMethodAccept to KotlinFunctionMetadata model class. Deprecated referencedMethodAccept(Clazz, MemberVisitor) in favour of referencedMethodAccept(MemberVisitor) in KotlinFunctionMetadata model class. Add TransformedStringMatcher . Add ClassFeatureNameCollector . Add var-arg constructor to ClassPath . Add DataEntryClassInfoFilter . Add NamedDataEntry . Refactor CodeLocation#getClassName as getExternalClassName to comply with the types naming convention. Make TypedReferenceValue.ALLOW_INCOMPLETE_CLASS_HIERARCHY private, add a getter TypedReferenceValue.allowsIncompleteClassHierarchy() instead.","title":"API Improvements"},{"location":"releasenotes.html#bug-fixes_3","text":"Fix side effect on DetailedArrayReferenceValue modifying values at previous offsets on array store instructions during PartialEvaluator execution. Fix JvmTransferRelation to produce a successor in case of missing interprocedural call edge (e.g., in case of incomplete call resolution). Fix call resolution for invokedynamic (issue #63). There might now be calls with incomplete target information. By default, these calls will not be distributed to visitors, but this can be enabled by setting the skipIncompleteCalls option in the call resolver. Fix leading $ being stripped from inner classes by the ClassReferenceFixer . This prevents classes with names like Foo$$Bar incorrectly having their simple name changed from $Bar to Bar .","title":"Bug fixes"},{"location":"releasenotes.html#version-903","text":"","title":"Version 9.0.3"},{"location":"releasenotes.html#java-support","text":"Update maximum supported Java class version to 63.65535 (Java 19 ea). ( PGD-247 )","title":"Java support"},{"location":"releasenotes.html#improved_6","text":"Add utility to produce dot-graphs for control flow automatons ( CfaUtil.toDot(cfa) , example VisualizeCfa ). Add support for heap slicing on call sites and heap reconstruction on return sites in dataflow analysis heap tree model. Add support for differential map representation to be used in the data flow analysis.","title":"Improved"},{"location":"releasenotes.html#api-improvements_3","text":"Split ProgramLocationDependentTransferRelation into forward and backward variants. Add ClassPoolClassLoader utility for loading ProGuardCORE classes. Add builders for CPA runs.","title":"API Improvements"},{"location":"releasenotes.html#version-902","text":"","title":"Version 9.0.2"},{"location":"releasenotes.html#improved_7","text":"JvmMemoryLocationTransferRelation does not rely anymore on a pre-computed abstract reachability graph.","title":"Improved"},{"location":"releasenotes.html#improvements-to-kotlin-metadata-initialization","text":"Several improvements to Kotlin metadata initialization now allow building the Kotlin metadata model for library classes ( LibraryClass ): KotlinMetadataInitializer provides a new public method initialize(Clazz, int, int[], String[], String[], int, String, String) to initialize the Kotlin metadata model for a given class. ClassReader can now build the Kotlin metadata model by setting includeKotlinMetadata to true . LibraryClassReader can now read the Kotlin metadata annotation and provide the components to a consumer. An UnsupportedKotlinMetadata type is now assigned by the KotlinMetadataInitializer if the Kotlin metadata model could not be initialized correctly.","title":"Improvements to Kotlin metadata initialization"},{"location":"releasenotes.html#version-901","text":"","title":"Version 9.0.1"},{"location":"releasenotes.html#improved_8","text":"ExecutingInvocationUnit now loads values from static final fields. Initialize Kotlin lambda method references when the JVM method name is <anonymous> . Add the possibility of limiting the number of CodeAttributes contributing into CFA. Add the possibility of limiting the number of CodeAttributes considered by the CallResolver .","title":"Improved"},{"location":"releasenotes.html#bug-fixes_4","text":"Fix wrong handling of array types in ExecutingIvocationUnit and ParticularReferenceValue . ParticularReferenceValue sanity checks now take inheritance into consideration, improving call analysis. Prevent missing semicolon leading to an infinite loop in ClassUtil#internalMethodParameterCount . Make category 2 CPA taint sources affect only the most significant byte abstract state. Fix inconsistent usage of type names in the context of the PartialEvaluator that could result in trying to create an internal type string from a string that was already an internal type. Fix initialization of Kotlin callable references when using -Xno-optimized-callable-references compiler option. Fix createCache() delegation in ArgBamCpaRun","title":"Bug fixes"},{"location":"releasenotes.html#upgrade-considerations_1","text":"","title":"Upgrade considerations"},{"location":"releasenotes.html#type-name-convention","text":"PGC has different representation for type string variables: External class name: com.guardsquare.SomeClass Internal class name: com/guardsquare/SomeClass Internal type (or just type ): Lcom/guardsquare/SomeClass; (for arrays e.g. [I , [Ljava/lang/Object; ) Internal class type: com/guardsquare/SomeClass (for arrays this is their internal type e.g. [I , [Ljava/lang/Object; ) See proguard.classfile.util.ClassUtil for useful methods to convert between the different representations. Since internal class name and type were used ambiguously, from version 9.0.1 the internal type is used consistently whenever we have a variable named type . Since this was not the case, this update might cause some type variables switching from the internal class name notation to the internal type notation, potentially breaking some logic if types are used by an external application using proguard-core.","title":"TYPE NAME CONVENTION"},{"location":"releasenotes.html#version-90-april-2022","text":"","title":"Version 9.0 (April 2022)"},{"location":"releasenotes.html#configurable-program-analysis-cpa","text":"CPA is a formalism for data flow analysis allowing seamless composition of various analyses and model checking techniques. Thus, it adds a framework for systematic development and extension of static analyses in a uniform structured way. Taint analysis is the first ProGuardCORE CPA. Its goal is to detect data flow between source and sink method calls, which is useful for detecting bugs and security flaws. The Taint Analysis manual page provides more information. Add configurable program analysis (CPA) for interprocedural data flow analysis development. Add taint analysis.","title":"Configurable program analysis (CPA)"},{"location":"releasenotes.html#bug-fixes_5","text":"Prevent linking a final method with a shadowing method in a subclass. Force Call#getArgumentCount() to be correct even if the actual argument values could not be calculated or have been cleared. Reset ExecutingInvocationUnit parameters array even when an exception happens.","title":"Bug fixes"},{"location":"releasenotes.html#version-807","text":"","title":"Version 8.0.7"},{"location":"releasenotes.html#java-support_1","text":"Update maximum supported Java class version to 62.65535 (Java 18 ea).","title":"Java support"},{"location":"releasenotes.html#improved_9","text":"Add support for Kotlin property synthetic delegate methods. Add ability to pass KotlinMetadataVersion to KotlinMetadataWriter / KotlinModuleWriter .","title":"Improved"},{"location":"releasenotes.html#version-806","text":"","title":"Version 8.0.6"},{"location":"releasenotes.html#improved_10","text":"Add support for writing out zip64 archives. Improve speed for ClassPool.contains method.","title":"Improved"},{"location":"releasenotes.html#version-805","text":"","title":"Version 8.0.5"},{"location":"releasenotes.html#improved_11","text":"Upgrade log4j2 dependency to v2.17.1 in response to CVE-2021-44832. Add support for reading and writing Kotlin 1.6 metadata.","title":"Improved"},{"location":"releasenotes.html#bug-fixes_6","text":"Fix CallResolver erroneously creating call edges to unimplemented interface methods. Make the DominatorCalculator skip methods with an empty CodeAttribute . Prevent updating Kotlin function names with mangled JVM method names in ClassReferenceFixer . Initialize Kotlin default implementation classes of annotation classes correctly in ClassReferenceInitializer . Correctly initialize Java Record component attributes in ClassReferenceInitializer .","title":"Bug fixes"},{"location":"releasenotes.html#api-changes_2","text":"KotlinInterfaceToDefaultImplsClassVisitor replaced by KotlinClassToDefaultImplsClassVisitor . Deprecate Kotlin class metadata flag IS_INLINE and replaced with IS_VALUE . Convert to/from Kotlin unsigned integers in Kotlin annotation unsigned type arguments. Initialize array dimension in Kotlin annotation ClassValue type arguments. Add support for Kotlin inline class underlying type to Kotlin metadata model. Add support to MemberDescriptorReferencedClassVisitor for visiting referenced Kotlin inline class parameters.","title":"API changes"},{"location":"releasenotes.html#version-804","text":"","title":"Version 8.0.4"},{"location":"releasenotes.html#improved_12","text":"Upgrade log4j2 dependency to v2.17 in response to CVE-2021-45105.","title":"Improved"},{"location":"releasenotes.html#api-improvements_4","text":"Add KotlinMetadataVersionFilter to filter classes based on the version of the attached metadata.","title":"API Improvements"},{"location":"releasenotes.html#version-803","text":"","title":"Version 8.0.3"},{"location":"releasenotes.html#improved_13","text":"Upgrade log4j2 dependency in response to CVE-2021-45046.","title":"Improved"},{"location":"releasenotes.html#version-802","text":"","title":"Version 8.0.2"},{"location":"releasenotes.html#improved_14","text":"Upgrade log4j2 dependency in response to CVE-2021-44228.","title":"Improved"},{"location":"releasenotes.html#api-improvements_5","text":"Add call resolving and graph traversal features to enable interprocedural control flow analyses.","title":"API Improvements"},{"location":"releasenotes.html#bug-fixes_7","text":"Fix potential StringIndexOutOfBoundsException while trimming attribute value spaces in SignedJarWriter . Fix referencedClass of Values generated by the ExecutingInvocationUnit . Fix potential StackOverflowError when using an AttributeVisitor to visit runtime invisible type annotations. Fix potential StringIndexOutOfBoundsException in KotlinCallableReferenceInitializer . Fix potential NullPointerException in KotlinInterClassPropertyReferenceInitializer . Fix wrong offset for complementary branch instruction when widening branch instructions in InstructionWriter . Fix potential ClassFormatError due to adding multiple annotation attributes when processing Kotlin code. Fix potential NullPointerException due to missing classes in ClassReferenceInitializer . Prevent making package-private final methods that are shadowed protected.","title":"Bug fixes"},{"location":"releasenotes.html#version-801","text":"","title":"Version 8.0.1"},{"location":"releasenotes.html#api-improvements_6","text":"Add LibraryClassBuilder and LibraryClassEditor classes to create and edit a LibraryClass . Add additional constructors to LibraryClass .","title":"API Improvements"},{"location":"releasenotes.html#bug-fixes_8","text":"Fix potential NullPointerException when initializing Kotlin callable references. Prevent requiring --enable-preview on a JVM for Java 16 class files (write class file version 60.0 instead of 60.65535 ). Fix potential NullPointerException when visiting referenced methods of Kotlin functions.","title":"Bug fixes"},{"location":"releasenotes.html#version-800","text":"","title":"Version 8.0.0"},{"location":"releasenotes.html#java-support_2","text":"Update maximum supported Java class version to 61.0 (Java 17).","title":"Java support"},{"location":"releasenotes.html#kotlin-support","text":"Add support for processing Kotlin 1.5 metadata. Update kotlinx metadata dependency to version 0.2.","title":"Kotlin support"},{"location":"releasenotes.html#api-improvements_7","text":"Add WarningLogger class to allow using a custom Log4j2 logger. Add Kotlin metadata model classes and visitors for Kotlin annotations. Add Kotlin metadata model enum for KmVariance . Add Kotlin metadata model enum for KmVersionRequirement(Kind|Level) . Add Kotlin metadata model enum for KmEffect(Type|InvocationKind) . Add Kotlin metadata flag IS_FUN for functional interfaces. Add Kotlin metadata flag HAS_NON_STABLE_PARAMETER_NAMES for Kotlin callables. Add error handler callback to KotlinMetadataInitializer . Add error handler callback to KotlinMetadataWriter . Add error handler callback to KotlinModuleReader . Add error handler callback to KotlinModuleWriter . Add Kotlin metadata flag IS_SECONDARY for constructors. Implement ClassVisitor in KotlinMetadataInitializer to allow easier initialization of Kotlin metadata. Implement ClassVisitor in KotlinMetadataWriter to allow easier writing of Kotlin metadata.","title":"API Improvements"},{"location":"releasenotes.html#api-changes_3","text":"KotlinTypeParameterVistor#visitClassParameter(Clazz, KotlinMetadata, KotlinTypeParameterMetadata) now has the correct signature: KotlinTypeParameterVistor#visitClassParameter(Clazz, KotlinClassKindMetadata, KotlinTypeParameterMetadata) . Rename AllKotlinPropertiesVisitor to AllPropertyVisitor . Rename AllConstructorsVisitor to AllConstructorVisitor . Rename AllFunctionsVisitor to AllFunctionVisitor . Remove `KotlinValueParameterVisitor.onNewFunctionStart()' method. Deprecate Kotlin metadata flag IS_PRIMARY for constructors.","title":"API changes"},{"location":"releasenotes.html#version-711","text":"","title":"Version 7.1.1"},{"location":"releasenotes.html#api-improvements_8","text":"Add KotlinTypeParameterFilter to allow filtering easily when visiting type parameters. Add KotlinValueParameterFilter to allow filtering easily when visiting value parameters.","title":"API improvements"},{"location":"releasenotes.html#bug-fixes_9","text":"Fix AllTypeParameterVisitor so that it visits type parameters defined in any kind of declaration container. Fix AllTypeParameterVisitor so that it visits type parameters of type aliases. Fix potential NullPointerException when initializing a Kotlin default implementation class that does not contain an initialized jvmSignature . Add missing equals method to ParticularReferenceValue . Fix incorrect handling of InterruptedException in ParallelAllClassVisitor . Fix potential ZipOutput alignment issue when writing large uncompressed zip entries. Fix potential ZipOutput synchronization issue when writing uncompressed zip entries. Fix potential NullPointerException when comparing strings with FixedStringMatcher . Fix potential NullPointerException when comparing strings with MatchedStringMatcher . Fix initialization of Kotlin callable references when using Kotlin >= 1.4.","title":"Bug fixes"},{"location":"releasenotes.html#version-71-june-2021","text":"","title":"Version 7.1 (June 2021)"},{"location":"releasenotes.html#java-support_3","text":"ProGuardCORE 7.1 now supports Java versions 14, 15 and 16: Add support for reading & writing Java 14, 15 and 16 class files. Add support for Java 14 sealed classes (permitted subclasses attributes). Add support for record attributes (previewed in Java 15/16, targeted for Java 17).","title":"Java support"},{"location":"releasenotes.html#improved-code-analysis","text":"The partial evaluator can now be used to reconstruct the specific values of String , StringBuilder and StringBuffer type objects. See analyzing code manual page for more information. The partial evaluator will now throw an IncompleteClassHierarchyException instead of IllegalArgumentException when an incomplete hierarchy is encountered. The partial evaluator will now throw an ExcessiveComplexityException if an instruction is visited more than stopAnalysisAfterNEvaluations times. Potentially throwing ldc instructions are now taken into account during partial evaluation, improving the accuracy of code analysis. Add support for multiple possible types during partial evaluation.","title":"Improved code analysis"},{"location":"releasenotes.html#performance-improvements","text":"Improve efficiency of building classes, methods and constant pools.","title":"Performance improvements"},{"location":"releasenotes.html#api-improvements_9","text":"Add ClassRenamer to allow renaming classes and members easily.","title":"API improvements"},{"location":"releasenotes.html#bug-fixes_10","text":"Add missing method reference in injected static initializer instructions. Add missing dimensions argument to CompactCodeAttributeComposer.multianewarray . Fix potential StackOverflowException when comparing multi-typed reference values. Fix handling of Kotlin nested class names which contain $ . Mark Module , ModuleMainClass and ModulePackages attributes as required. Fix potential ClassCastException in ConstructorMethodFilter . Fix potential NullPointerException for module classes in ClassPrinter. Fix storage and alignment of uncompressed zip entries. Fix processing of constant boolean arrays. Fix adding branch instructions with labels in CompactCodeAttributeComposer . Fix handling of array dereferencing in MultiTypedReferenceValue . Fix AllKotlinAnnotationVisitor so that it visits type alias annotations defined in any kind of declaration container. Move initialization of Kotlin declaration container's ownerClassName field from ClassReferenceInitializer to KotlinMetadataInitializer .","title":"Bug fixes"},{"location":"releasenotes.html#version-70-jan-2020","text":"Version Issue Module Explanation 7.0.1 DGD-2382 CORE Fixed processing of Kotlin 1.4 metadata annotations. 7.0.1 DGD-2390 CORE Fixed storage and alignment of uncompressed zip entries. 7.0.1 DGD-2338 CORE Fixed processing of constant boolean arrays. 7.0.1 CORE Fixed adding branch instructions with labels in CompactCodeAttributeComposer. 7.0.0 CORE Initial release of Kotlin support. 7.0.0 PGD-32 CORE Added support for Java 14 class files. 7.0.0 DGD-1780 CORE Removed dependency on internal sun.security API. 7.0.0 DGD-1800 CORE Fixed obfuscation of functional interfaces with abstract Object methods. 7.0.0 CORE Initial release, extracted from ProGuard.","title":"Version 7.0 (Jan 2020)"},{"location":"taintcpa.html","text":"Taint analysis with CPA Taint analysis aims for detecting a data flow between taint sources and sinks. Configurable program analysis (CPA) is a formalism suitable for integrating multiple data flow analyses in one tool. Taints can be traced in few simple steps. Modeling the control flow A control flow automaton (CFA) is a graph with nodes being bytecode offsets and edges being instructions or calls connecting them. You can create a CFA from the program class pool: // Create the control flow automaton (CFA). JvmCfa cfa = CfaUtil . createInterproceduralCfaFromClassPool ( programClassPool ); Defining taint sources Every taint analysis data flow starts from a taint source. Any Java method can be a taint source. You have several options of how a taint source can behave. A source may: taint the calling instance, return the taint, taint its actual parameters of nonprimitive types, taint static fields. For creating a taint you need its fully qualified name and the expected tainting pattern. Let us create a simple taint source returning a tainted string: // Create a taint source. TaintSource source = new TaintSource ( \"LMain;source()Ljava/lang/String;\" , // the fully qualified name of a source method false , // whether the source taints the calling instance true , // whether the source taints its return Collections . emptySet (), // a set of tainted arguments Collections . emptySet ()); // a set of tainted global variables Defining taint sinks Taint sinks are the counterpart of taint sources sensitive to a taint. A taint sink may be sensitive to the calling instance, actual parameters, static fields. Given the fully qualified name and the sensitivity model you can straightforwardly create a taint sink like the one sensitive to its only argument: // Create a taint sink. JvmTaintSink sink = new JvmTaintSink ( \"LMain;sink(Ljava/lang/String;)V\" , // the fully qualified name of a sink method false , // whether the sink is sensitive to the calling instance Collections . singleton ( 1 ), // a set of sensitive arguments Collections . emptySet ()); // a set of sensitive global variables Note: The argument enumeration for both taint sources and taint sinks starts from one and does not depend on whether the method is static. The calling distance is handled by a separate boolean constructor parameter. Setting up a CPA run CPA runs encapsulate the initialization of CPA components and allow configuring the analysis. The CPA run needs to know in which method the analysis needs to start and how deep the call stack for the interprocedural analysis should be. All calls overflowing the stack, as well as all library methods, are approximated intraprocedurally as propagating the taint from their calling instance and arguments into the return value. You can create a CPA run for analyzing Main.main(String args) with an unlimited call stack as follows: // Create the CPA run. JvmTaintMemoryLocationBamCpaRun cpaRun = new JvmTaintMemoryLocationBamCpaRun ( cfa , // a CFA Collections . singleton ( source ), // a set of taint sources new MethodSignature ( \"Main\" , \"main\" , \"([Ljava/lang/String)V\" ), // the signature of the main method - 1 , // the maximum depth of the call stack analyzed interprocedurally. // 0 means intra-procedural analysis. // < 0 means unlimited depth. TaintAbstractState . bottom , // a cut-off threshold Collections . singleton ( sink )); // a collection of taint sinks Running the analysis and obtaining witness traces The analysis execution can be done in a single line together with generating witness traces: // Run the analysis and get witness traces. Set < List < JvmMemoryLocation >> traces = cpaRun . extractLinearTraces (); Interpreting the analysis result The result of the analysis is a set of witness traces, if there is a data flow detected. A witness trace is a list of memory locations at specific program locations. For instance, the class below // Run the analysis and get witness traces. public class Main { public static void main () { sink ( callee ()); } public static String callee () { return source (); } } would generate a witness trace consisting of two top stack locations, one after the taint source in callee() and another before the call to sink(String s) : [ JvmStackLocation ( 0 ) @LMain ; main () V : 3 , JvmStackLocation ( 0 ) @LMain ; callee () Ljava / lang / String ;: 3 ] Note that the traces returned by the CPA run go from the taint sink to the taint source. There are four types of memory locations: stack locations identified by their offsets from the operand stack top, local variable locations identified by their indices in the local variable array, static field locations identified by their fully qualified names, heap locations identified by their abstract references. Complete example: AnalyzeTaints.java","title":"Taint analysis with CPA"},{"location":"taintcpa.html#taint-analysis-with-cpa","text":"Taint analysis aims for detecting a data flow between taint sources and sinks. Configurable program analysis (CPA) is a formalism suitable for integrating multiple data flow analyses in one tool. Taints can be traced in few simple steps.","title":"Taint analysis with CPA"},{"location":"taintcpa.html#modeling-the-control-flow","text":"A control flow automaton (CFA) is a graph with nodes being bytecode offsets and edges being instructions or calls connecting them. You can create a CFA from the program class pool: // Create the control flow automaton (CFA). JvmCfa cfa = CfaUtil . createInterproceduralCfaFromClassPool ( programClassPool );","title":"Modeling the control flow"},{"location":"taintcpa.html#defining-taint-sources","text":"Every taint analysis data flow starts from a taint source. Any Java method can be a taint source. You have several options of how a taint source can behave. A source may: taint the calling instance, return the taint, taint its actual parameters of nonprimitive types, taint static fields. For creating a taint you need its fully qualified name and the expected tainting pattern. Let us create a simple taint source returning a tainted string: // Create a taint source. TaintSource source = new TaintSource ( \"LMain;source()Ljava/lang/String;\" , // the fully qualified name of a source method false , // whether the source taints the calling instance true , // whether the source taints its return Collections . emptySet (), // a set of tainted arguments Collections . emptySet ()); // a set of tainted global variables","title":"Defining taint sources"},{"location":"taintcpa.html#defining-taint-sinks","text":"Taint sinks are the counterpart of taint sources sensitive to a taint. A taint sink may be sensitive to the calling instance, actual parameters, static fields. Given the fully qualified name and the sensitivity model you can straightforwardly create a taint sink like the one sensitive to its only argument: // Create a taint sink. JvmTaintSink sink = new JvmTaintSink ( \"LMain;sink(Ljava/lang/String;)V\" , // the fully qualified name of a sink method false , // whether the sink is sensitive to the calling instance Collections . singleton ( 1 ), // a set of sensitive arguments Collections . emptySet ()); // a set of sensitive global variables Note: The argument enumeration for both taint sources and taint sinks starts from one and does not depend on whether the method is static. The calling distance is handled by a separate boolean constructor parameter.","title":"Defining taint sinks"},{"location":"taintcpa.html#setting-up-a-cpa-run","text":"CPA runs encapsulate the initialization of CPA components and allow configuring the analysis. The CPA run needs to know in which method the analysis needs to start and how deep the call stack for the interprocedural analysis should be. All calls overflowing the stack, as well as all library methods, are approximated intraprocedurally as propagating the taint from their calling instance and arguments into the return value. You can create a CPA run for analyzing Main.main(String args) with an unlimited call stack as follows: // Create the CPA run. JvmTaintMemoryLocationBamCpaRun cpaRun = new JvmTaintMemoryLocationBamCpaRun ( cfa , // a CFA Collections . singleton ( source ), // a set of taint sources new MethodSignature ( \"Main\" , \"main\" , \"([Ljava/lang/String)V\" ), // the signature of the main method - 1 , // the maximum depth of the call stack analyzed interprocedurally. // 0 means intra-procedural analysis. // < 0 means unlimited depth. TaintAbstractState . bottom , // a cut-off threshold Collections . singleton ( sink )); // a collection of taint sinks","title":"Setting up a CPA run"},{"location":"taintcpa.html#running-the-analysis-and-obtaining-witness-traces","text":"The analysis execution can be done in a single line together with generating witness traces: // Run the analysis and get witness traces. Set < List < JvmMemoryLocation >> traces = cpaRun . extractLinearTraces ();","title":"Running the analysis and obtaining witness traces"},{"location":"taintcpa.html#interpreting-the-analysis-result","text":"The result of the analysis is a set of witness traces, if there is a data flow detected. A witness trace is a list of memory locations at specific program locations. For instance, the class below // Run the analysis and get witness traces. public class Main { public static void main () { sink ( callee ()); } public static String callee () { return source (); } } would generate a witness trace consisting of two top stack locations, one after the taint source in callee() and another before the call to sink(String s) : [ JvmStackLocation ( 0 ) @LMain ; main () V : 3 , JvmStackLocation ( 0 ) @LMain ; callee () Ljava / lang / String ;: 3 ] Note that the traces returned by the CPA run go from the taint sink to the taint source. There are four types of memory locations: stack locations identified by their offsets from the operand stack top, local variable locations identified by their indices in the local variable array, static field locations identified by their fully qualified names, heap locations identified by their abstract references. Complete example: AnalyzeTaints.java","title":"Interpreting the analysis result"}]}